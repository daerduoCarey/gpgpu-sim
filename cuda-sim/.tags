!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
-name-prefix	Makefile	/^	bison --name-prefix=ptx_ -v -d ptx.y --file-prefix=$(OUTPUT_DIR)\/ptx$/;"	m
-name-prefix	Makefile	/^	bison --name-prefix=ptxinfo_ -v -d ptxinfo.y --file-prefix=$(OUTPUT_DIR)\/ptxinfo$/;"	m
-outfile	Makefile	/^	flex --outfile=$(OUTPUT_DIR)\/lex.ptx_.c ptx.l $/;"	m
-outfile	Makefile	/^	flex --outfile=$(OUTPUT_DIR)\/lex.ptxinfo_.c ptxinfo.l $/;"	m
ARRAY_IDENTIFIER	ptx_parser.h	99;"	d
ARRAY_IDENTIFIER_NO_DIM	ptx_parser.h	98;"	d
CC	Makefile	/^	CC = icc$/;"	m
CLOCK64_REG	opcodes.h	/^   CLOCK64_REG,$/;"	e	enum:special_regs
CLOCK_REG	opcodes.h	/^   CLOCK_REG,$/;"	e	enum:special_regs
CPP	Makefile	/^	CPP = icpc$/;"	m
CPP	Makefile	/^CPP = g++ $(SNOW)$/;"	m
CTAID_REG	opcodes.h	/^   CTAID_REG,$/;"	e	enum:special_regs
CUDASIM_H_INCLUDED	cuda-sim.h	29;"	d
CUDA_DEVICE_PRINTF_INCLUDED	cuda_device_printf.h	29;"	d
CUDA_FLOAT_MATH_FUNCTIONS	cuda-math.h	101;"	d
CUDA_MATH	cuda-math.h	68;"	d
CXX_OPT	Makefile	/^CXX_OPT = $(OPT)$/;"	m
CmpOp	instructions.cc	/^bool CmpOp( int type, ptx_reg_t a, ptx_reg_t b, unsigned cmpop )$/;"	f
DEBUG	Makefile	/^DEBUG?=0$/;"	m
DEF	ptx_parser.cc	120;"	d	file:
DEF	ptx_parser.cc	122;"	d	file:
ENVREG_REG	opcodes.h	/^   ENVREG_REG,$/;"	e	enum:special_regs
GRIDID_REG	opcodes.h	/^   GRIDID_REG,$/;"	e	enum:special_regs
HALFCLOCK_ID	opcodes.h	/^   HALFCLOCK_ID,$/;"	e	enum:special_regs
INTEL	Makefile	/^INTEL=0$/;"	m
INT_MAX	cuda-math.h	75;"	d
LANEID_REG	opcodes.h	/^   LANEID_REG,$/;"	e	enum:special_regs
LANEMASK_EQ_REG	opcodes.h	/^   LANEMASK_EQ_REG,$/;"	e	enum:special_regs
LANEMASK_GE_REG	opcodes.h	/^   LANEMASK_GE_REG,$/;"	e	enum:special_regs
LANEMASK_GT_REG	opcodes.h	/^   LANEMASK_GT_REG,$/;"	e	enum:special_regs
LANEMASK_LE_REG	opcodes.h	/^   LANEMASK_LE_REG,$/;"	e	enum:special_regs
LANEMASK_LT_REG	opcodes.h	/^   LANEMASK_LT_REG,$/;"	e	enum:special_regs
MAX	cuda-sim.cc	1690;"	d	file:
MAX_CLASS_KER	cuda-sim.cc	1132;"	d	file:
MAX_INST_SIZE	cuda-sim.cc	181;"	d	file:
MEM_BLOCK_SIZE	memory.h	50;"	d
MEM_MAP_RESIZE	memory.h	36;"	d
MEM_MAP_RESIZE	memory.h	38;"	d
MY_CAS_I	instructions.cc	647;"	d	file:
MY_DEC_I	instructions.cc	645;"	d	file:
MY_EXCH	instructions.cc	649;"	d	file:
MY_INC_I	instructions.cc	644;"	d	file:
MY_MAX_F	instructions.cc	639;"	d	file:
MY_MAX_I	instructions.cc	638;"	d	file:
MY_MIN_F	instructions.cc	642;"	d	file:
MY_MIN_I	instructions.cc	641;"	d	file:
NCTAID_REG	opcodes.h	/^   NCTAID_REG,$/;"	e	enum:special_regs
NON_ARRAY_IDENTIFIER	ptx_parser.h	97;"	d
NO_BRANCH_DIVERGENCE	cuda-sim.h	127;"	d
NSMID_REG	opcodes.h	/^   NSMID_REG,$/;"	e	enum:special_regs
NTID_REG	opcodes.h	/^   NTID_REG,$/;"	e	enum:special_regs
NUM_OPCODES	opcodes.h	/^   NUM_OPCODES$/;"	e	enum:opcode_t
NWARPID_REG	opcodes.h	/^   NWARPID_REG,$/;"	e	enum:special_regs
OBJS	Makefile	/^OBJS	:= $(OUTPUT_DIR)\/ptx_parser.o $(OUTPUT_DIR)\/ptx_loader.o $(OUTPUT_DIR)\/cuda_device_printf.o $(OUTPUT_DIR)\/instructions.o $(OUTPUT_DIR)\/cuda-sim.o $(OUTPUT_DIR)\/ptx_ir.o $(OUTPUT_DIR)\/ptx_sim.o  $(OUTPUT_DIR)\/memory.o $(OUTPUT_DIR)\/ptx-stats.o $(OUTPUT_DIR)\/decuda_pred_table\/decuda_pred_table.o $(OUTPUT_DIR)\/ptx.tab.o $(OUTPUT_DIR)\/lex.ptx_.o $(OUTPUT_DIR)\/ptxinfo.tab.o $(OUTPUT_DIR)\/lex.ptxinfo_.o$/;"	m
OPT	Makefile	/^	OPT := -g3 -Wall  -Wno-unused-function -Wno-sign-compare$/;"	m
OPT	Makefile	/^OPT	:=  -O3 -g3 -Wall -Wno-unused-function -Wno-sign-compare$/;"	m
OP_DEF	cuda-sim.cc	1208;"	d	file:
OP_DEF	cuda-sim.cc	1210;"	d	file:
OP_DEF	cuda-sim.cc	813;"	d	file:
OP_DEF	cuda-sim.cc	815;"	d	file:
OP_DEF	instructions.cc	49;"	d	file:
OP_DEF	instructions.cc	51;"	d	file:
OP_DEF	opcodes.h	32;"	d
OP_DEF	opcodes.h	35;"	d
OUTPUT_DIR	Makefile	/^OUTPUT_DIR=$(SIM_OBJ_FILES_DIR)\/cuda-sim$/;"	m
PM_REG	opcodes.h	/^   PM_REG,$/;"	e	enum:special_regs
PTX_LOADER_H_INCLUDED	ptx_loader.h	29;"	d
PTX_PARSE_DPRINTF	ptx_parser.cc	77;"	d	file:
RECONVERGE_RETURN_PC	cuda-sim.h	126;"	d
SAD	instructions.cc	3027;"	d	file:
SMID_REG	opcodes.h	/^   SMID_REG,$/;"	e	enum:special_regs
SRCS	Makefile	/^SRCS = $(shell ls *.cc)$/;"	m
STR_SIZE	cuda-sim.cc	458;"	d	file:
STR_SIZE	ptx_ir.cc	42;"	d	file:
TID_REG	opcodes.h	/^   TID_REG,$/;"	e	enum:special_regs
TRACE	Makefile	/^TRACE?=0$/;"	m
Tmp_ids	ptx_ir.h	/^   std::set<int> Tmp_ids;$/;"	m	struct:basic_block_t
Tx	ptx_ir.h	/^   unsigned int Tx,Ty; \/\/tiling factor dimensions of layout of texels per 64B cache block$/;"	m	struct:textureInfo
Tx_numbits	ptx_ir.h	/^   unsigned int Tx_numbits,Ty_numbits; \/\/log2(T)$/;"	m	struct:textureInfo
Ty	ptx_ir.h	/^   unsigned int Tx,Ty; \/\/tiling factor dimensions of layout of texels per 64B cache block$/;"	m	struct:textureInfo
Ty_numbits	ptx_ir.h	/^   unsigned int Tx_numbits,Ty_numbits; \/\/log2(T)$/;"	m	struct:textureInfo
WARPID_REG	opcodes.h	/^   WARPID_REG,$/;"	e	enum:special_regs
WARPSZ_REG	opcodes.h	/^   WARPSZ_REG$/;"	e	enum:special_regs
__CUDA_INTERNAL_COMPILATION__	cuda-math.h	103;"	d
__CUDA_INTERNAL_COMPILATION__	cuda-math.h	105;"	d
__attribute__	cuda-math.h	106;"	d
__attribute__	cuda-math.h	74;"	d
__ll2float_rd	cuda-math.h	/^float __ll2float_rd(long long int a) {$/;"	f	namespace:cuda_math
__ll2float_ru	cuda-math.h	/^float __ll2float_ru(long long int a) {$/;"	f	namespace:cuda_math
__ll2float_rz	cuda-math.h	/^float __ll2float_rz(long long int a) {$/;"	f	namespace:cuda_math
a	instructions.cc	/^   int a;$/;"	m	union:intfloat	file:
abs_impl	instructions.cc	/^void abs_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
add_1vector_operand	ptx_parser.cc	/^void add_1vector_operand( const char *d1 ) $/;"	f
add_2vector_operand	ptx_parser.cc	/^void add_2vector_operand( const char *d1, const char *d2 ) $/;"	f
add_3vector_operand	ptx_parser.cc	/^void add_3vector_operand( const char *d1, const char *d2, const char *d3 ) $/;"	f
add_4vector_operand	ptx_parser.cc	/^void add_4vector_operand( const char *d1, const char *d2, const char *d3, const char *d4 ) $/;"	f
add_address_operand	ptx_parser.cc	/^void add_address_operand( const char *identifier, int offset ) $/;"	f
add_address_operand2	ptx_parser.cc	/^void add_address_operand2( int offset )$/;"	f
add_alignment_spec	ptx_parser.cc	/^void add_alignment_spec( int spec )$/;"	f
add_arg	ptx_ir.h	/^   void add_arg( const symbol *arg )$/;"	f	class:function_info
add_array_initializer	ptx_parser.cc	/^void add_array_initializer()$/;"	f
add_builtin_operand	ptx_parser.cc	/^void add_builtin_operand( int builtin, int dim_modifier ) $/;"	f
add_constptr	ptx_parser.cc	/^void add_constptr(const char* identifier1, const char* identifier2, int offset)$/;"	f
add_count	ptx-stats.cc	/^    void add_count(const ptx_instruction * pInsn, int count = 1)$/;"	f	class:ptx_inflight_memory_insn_tracker
add_data	ptx_ir.h	/^   void add_data( param_t v ) { $/;"	f	class:param_info
add_directive	ptx_parser.cc	/^void add_directive() $/;"	f
add_double_operand	ptx_parser.cc	/^void add_double_operand( const char *d1, const char *d2 )$/;"	f
add_extern_spec	ptx_parser.cc	/^void add_extern_spec() $/;"	f
add_file	ptx_parser.cc	/^void add_file( unsigned num, const char *filename )$/;"	f
add_function	ptx_ir.cc	/^void symbol_table::add_function( function_info *func, const char *filename, unsigned linenumber )$/;"	f	class:symbol_table
add_function_arg	ptx_parser.cc	/^void add_function_arg()$/;"	f
add_function_decl	ptx_ir.cc	/^bool symbol_table::add_function_decl( const char *name, int entry_point, function_info **func_info, symbol_table **sym_table )$/;"	f	class:symbol_table
add_function_name	ptx_parser.cc	/^void add_function_name( const char *name ) $/;"	f
add_identifier	ptx_parser.cc	/^void add_identifier( const char *identifier, int array_dim, unsigned array_ident ) $/;"	f
add_impl	instructions.cc	/^void add_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
add_initializer	ptx_ir.cc	/^void symbol::add_initializer( const std::list<operand_info> &init )$/;"	f	class:symbol
add_inst	ptx_ir.h	/^   void add_inst( const std::list<ptx_instruction*> &instructions )$/;"	f	class:function_info
add_instruction	ptx_parser.cc	/^void add_instruction() $/;"	f
add_label	ptx_parser.cc	/^void add_label( const char *identifier ) $/;"	f
add_literal_double	ptx_parser.cc	/^void add_literal_double( double value ) $/;"	f
add_literal_float	ptx_parser.cc	/^void add_literal_float( float value ) $/;"	f
add_literal_int	ptx_parser.cc	/^void add_literal_int( int value ) $/;"	f
add_memory_operand	ptx_parser.cc	/^void add_memory_operand() $/;"	f
add_neg_pred_operand	ptx_parser.cc	/^void add_neg_pred_operand( const char *identifier ) $/;"	f
add_offset	ptx_ir.h	/^   void add_offset( unsigned offset ) { m_offset = offset; }$/;"	f	class:param_info
add_opcode	ptx_parser.cc	/^void add_opcode( int opcode ) $/;"	f
add_option	ptx_parser.cc	/^void add_option( int option ) $/;"	f
add_param	ptx_ir.h	/^   void add_param( const char *name, struct param_t value )$/;"	f	class:function_info
add_param_data	cuda-sim.cc	/^void function_info::add_param_data( unsigned argn, struct gpgpu_ptx_sim_arg *args )$/;"	f	class:function_info
add_param_name_type_size	cuda-sim.cc	/^void function_info::add_param_name_type_size( unsigned index, std::string name, int type, size_t size, bool ptr, memory_space_t space )$/;"	f	class:function_info
add_pragma	ptx_parser.cc	/^void add_pragma( const char *str )$/;"	f
add_pred	ptx_parser.cc	/^void add_pred( const char *identifier, int neg, int predModifier ) $/;"	f
add_ptr_spec	ptx_parser.cc	/^void add_ptr_spec( enum _memory_space_t spec ) $/;"	f
add_return_var	ptx_ir.h	/^   void add_return_var( const symbol *rv )$/;"	f	class:function_info
add_scalar_operand	ptx_parser.cc	/^void add_scalar_operand( const char *identifier ) $/;"	f
add_scalar_type_spec	ptx_parser.cc	/^void add_scalar_type_spec( int type_spec ) $/;"	f
add_space_spec	ptx_parser.cc	/^void add_space_spec( enum _memory_space_t spec, int value ) $/;"	f
add_thread	ptx_sim.cc	/^void ptx_cta_info::add_thread( ptx_thread_info *thd )$/;"	f	class:ptx_cta_info
add_type	ptx_ir.cc	/^type_info *symbol_table::add_type( function_info *func )$/;"	f	class:symbol_table
add_type	ptx_ir.cc	/^type_info *symbol_table::add_type( memory_space_t space_spec, int scalar_type_spec, int vector_spec, int alignment_spec, int extern_spec )$/;"	f	class:symbol_table
add_variable	ptx_ir.cc	/^symbol *symbol_table::add_variable( const char *identifier, const type_info *type, unsigned size, const char *filename, unsigned line )$/;"	f	class:symbol_table
add_variables	ptx_parser.cc	/^void add_variables() $/;"	f
add_vector_spec	ptx_parser.cc	/^void add_vector_spec(int spec ) $/;"	f
add_version_info	ptx_parser.cc	/^void add_version_info( float ver, unsigned ext )$/;"	f
addc_impl	instructions.cc	/^void addc_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
addp_impl	instructions.cc	/^void addp_impl( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f
address_expression	ptx.y	/^address_expression: IDENTIFIER { add_address_operand($1,0); }$/;"	l
address_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
addressable_spec	ptx.y	/^addressable_spec: CONST_DIRECTIVE {  add_space_spec(const_space,$1); }$/;"	l
align_spec	ptx.y	/^align_spec: ALIGN_DIRECTIVE INT_OPERAND { add_alignment_spec($2); }$/;"	l
alloc_global	ptx_ir.h	/^   void  alloc_global( unsigned num_bytes ) { m_global_next += num_bytes;}$/;"	f	class:symbol_table
alloc_local	ptx_ir.h	/^   void  alloc_local( unsigned num_bytes ) { m_local_next += num_bytes;}$/;"	f	class:symbol_table
alloc_shared	ptx_ir.h	/^   void  alloc_shared( unsigned num_bytes ) { m_shared_next += num_bytes;}$/;"	f	class:symbol_table
alloc_tex	ptx_ir.h	/^   void  alloc_tex( unsigned num_bytes ) { m_tex_next += num_bytes;}$/;"	f	class:symbol_table
and_impl	instructions.cc	/^void and_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
andn_impl	instructions.cc	/^void andn_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
arch_reg_num	ptx_ir.h	/^   int arch_reg_num() const { return m_value.m_symbolic->arch_reg_num(); }$/;"	f	class:operand_info
arch_reg_num	ptx_ir.h	/^   int arch_reg_num(unsigned n) const { return (m_value.m_vector_symbolic[n])? m_value.m_vector_symbolic[n]->arch_reg_num() : -1; }$/;"	f	class:operand_info
arch_reg_num	ptx_ir.h	/^   unsigned arch_reg_num() const$/;"	f	class:symbol
arg_buffer_list_t	ptx_ir.h	/^typedef std::list< arg_buffer_t > arg_buffer_list_t;$/;"	t
arg_buffer_t	ptx_ir.h	/^   arg_buffer_t( const arg_buffer_t &another )$/;"	f	class:arg_buffer_t
arg_buffer_t	ptx_ir.h	/^   arg_buffer_t( const symbol *dst_sym, const operand_info &src_op, ptx_reg_t source_value ) : m_src_op(src_op)$/;"	f	class:arg_buffer_t
arg_buffer_t	ptx_ir.h	/^   arg_buffer_t( const symbol *dst_sym, const operand_info &src_op, void *source_param_value_array, unsigned array_size ) : m_src_op(src_op)$/;"	f	class:arg_buffer_t
arg_buffer_t	ptx_ir.h	/^   arg_buffer_t()$/;"	f	class:arg_buffer_t
arg_buffer_t	ptx_ir.h	/^class arg_buffer_t {$/;"	c
assign_bb	ptx_ir.h	/^   void assign_bb(basic_block_t* basic_block) \/\/assign instruction to a basic block$/;"	f	class:ptx_instruction
atom_callback	instructions.cc	/^void atom_callback( const inst_t* inst, ptx_thread_info* thread )$/;"	f
atom_impl	instructions.cc	/^void atom_impl( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f
atomic_operation_spec	ptx.y	/^atomic_operation_spec: ATOMIC_AND { add_option(ATOMIC_AND); } $/;"	l
attribute_exposed_latency	ptx-stats.cc	/^    void attribute_exposed_latency(int count = 1)$/;"	f	class:ptx_inflight_memory_insn_tracker
b	instructions.cc	/^   float b;$/;"	m	union:intfloat	file:
bar_sync_impl	instructions.cc	/^void bar_sync_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
basic_block_t	ptx_ir.h	/^   basic_block_t( unsigned ID, ptx_instruction *begin, ptx_instruction *end, bool entry, bool ex)$/;"	f	struct:basic_block_t
basic_block_t	ptx_ir.h	/^struct basic_block_t {$/;"	s
bb_id	ptx_ir.h	/^   unsigned bb_id;$/;"	m	struct:basic_block_t
bfe_impl	instructions.cc	/^void bfe_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
bfi_impl	instructions.cc	/^void bfi_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
bfind_impl	instructions.cc	/^void bfind_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
bits	ptx_sim.h	/^   } bits;$/;"	m	union:ptx_reg_t	typeref:struct:ptx_reg_t::__anon1
block_spec	ptx.y	/^block_spec: MAXNTID_DIRECTIVE INT_OPERAND COMMA INT_OPERAND COMMA INT_OPERAND {func_header_info_int(".maxntid", $2);$/;"	l
block_spec_list	ptx.y	/^block_spec_list: block_spec$/;"	l
bra_impl	instructions.cc	/^void bra_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
branch_taken	ptx_sim.h	/^   bool branch_taken() const$/;"	f	class:ptx_thread_info
break_impl	instructions.cc	/^void break_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
breakaddr_impl	instructions.cc	/^void breakaddr_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
brev_impl	instructions.cc	/^void brev_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
brkpt_impl	instructions.cc	/^void brkpt_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
brx_impl	instructions.cc	/^void brx_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
builtin_operand	ptx.y	/^builtin_operand: SPECIAL_REGISTER DIMENSION_MODIFIER { add_builtin_operand($1,$2); }$/;"	l
builtin_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
cache_option	ptx_ir.h	/^   unsigned cache_option() const { return m_cache_option; }$/;"	f	class:ptx_instruction
call_impl	instructions.cc	/^void call_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
callp_impl	instructions.cc	/^void callp_impl( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f
callstack_pop	ptx_sim.cc	/^bool ptx_thread_info::callstack_pop()$/;"	f	class:ptx_thread_info
callstack_pop_plus	ptx_sim.cc	/^bool ptx_thread_info::callstack_pop_plus()$/;"	f	class:ptx_thread_info
callstack_push	ptx_sim.cc	/^void ptx_thread_info::callstack_push( unsigned pc, unsigned rpc, const symbol *return_var_src, const symbol *return_var_dst, unsigned call_uid )$/;"	f	class:ptx_thread_info
callstack_push_plus	ptx_sim.cc	/^void ptx_thread_info::callstack_push_plus( unsigned pc, unsigned rpc, const symbol *return_var_src, const symbol *return_var_dst, unsigned call_uid )$/;"	f	class:ptx_thread_info
change_double_operand_type	ptx_parser.cc	/^void change_double_operand_type( int operand_type )$/;"	f
change_memory_addr_space	ptx_parser.cc	/^void change_memory_addr_space(const char *identifier) $/;"	f
change_operand_lohi	ptx_parser.cc	/^void change_operand_lohi( int lohi )$/;"	f
change_operand_neg	ptx_parser.cc	/^void change_operand_neg( )$/;"	f
checkExecutionStatusAndUpdate	cuda-sim.h	/^    virtual void checkExecutionStatusAndUpdate(warp_inst_t &inst, unsigned t, unsigned tid)$/;"	f	class:functionalCoreSim
check_cta_thread_status_and_reset	ptx_sim.cc	/^void ptx_cta_info::check_cta_thread_status_and_reset()$/;"	f	class:ptx_cta_info
check_for_duplicates	ptx_parser.cc	/^bool check_for_duplicates( const char *identifier )$/;"	f
check_operands	ptx_ir.cc	/^static std::list<operand_info> check_operands( int opcode,$/;"	f	file:
check_target_extension	ptx_sim.h	/^      void check_target_extension( const char *ext ) $/;"	f	class:ptx_version
chop	instructions.cc	/^ptx_reg_t chop( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
clamp	instructions.cc	/^unsigned clamp( unsigned x, unsigned y, unsigned mx, unsigned my, size_t elem_size )$/;"	f
clearRPC	ptx_sim.h	/^   void clearRPC()$/;"	f	class:ptx_thread_info
clear_modifiedregs	ptx_sim.h	/^   void clear_modifiedregs() { m_debug_trace_regs_modified.back().clear(); m_debug_trace_regs_read.back().clear(); }$/;"	f	class:ptx_thread_info
clear_ptxinfo	cuda-sim.cc	/^void clear_ptxinfo()$/;"	f
clz_impl	instructions.cc	/^void clz_impl( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f
cnot_impl	instructions.cc	/^void cnot_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
compare_spec	ptx.y	/^compare_spec:EQ_OPTION { add_option(EQ_OPTION); } $/;"	l
connect_basic_blocks	ptx_ir.cc	/^void function_info::connect_basic_blocks( ) \/\/iterate across m_basic_blocks of function, connecting basic blocks together$/;"	f	class:function_info
connect_break_targets	ptx_ir.cc	/^bool function_info::connect_break_targets() \/\/connecting break instructions with proper targets$/;"	f	class:function_info
const_iterator	ptx_ir.h	/^   typedef std::vector<operand_info>::const_iterator const_iterator;$/;"	t	class:ptx_instruction
const_iterator_begin	ptx_ir.h	/^   iterator const_iterator_begin() { return m_consts.begin();}$/;"	f	class:symbol_table
const_iterator_end	ptx_ir.h	/^   iterator const_iterator_end() { return m_consts.end();}$/;"	f	class:symbol_table
copy_arg_to_buffer	ptx_ir.cc	/^arg_buffer_t copy_arg_to_buffer(ptx_thread_info * thread, operand_info actual_param_op, const symbol * formal_param)$/;"	f
copy_args_into_buffer_list	ptx_ir.cc	/^void copy_args_into_buffer_list( const ptx_instruction * pI, $/;"	f
copy_buffer_list_into_frame	ptx_ir.cc	/^void copy_buffer_list_into_frame(ptx_thread_info * thread, arg_buffer_list_t &arg_values) $/;"	f
copy_buffer_to_frame	ptx_ir.cc	/^void copy_buffer_to_frame(ptx_thread_info * thread, const arg_buffer_t &a) $/;"	f
cos_impl	instructions.cc	/^void cos_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
cpy_tid_to_reg	ptx_sim.cc	/^void ptx_thread_info::cpy_tid_to_reg( dim3 tid )$/;"	f	class:ptx_thread_info
createWarp	cuda-sim.cc	/^void  functionalCoreSim::createWarp(unsigned warpId)$/;"	f	class:functionalCoreSim
create_basic_blocks	ptx_ir.cc	/^void function_info::create_basic_blocks()$/;"	f	class:function_info
cuda_math	cuda-math.h	/^namespace cuda_math {$/;"	n
cvt_impl	instructions.cc	/^void cvt_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
cvta_impl	instructions.cc	/^void cvta_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
d2d	instructions.cc	/^ptx_reg_t d2d( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
d2x	instructions.cc	/^ptx_reg_t d2x( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
datatype2size	cuda-sim.cc	/^static unsigned datatype2size( unsigned data_type )$/;"	f	file:
decl_location	ptx_ir.h	/^   const std::string &decl_location() const { return m_decl_location;} $/;"	f	class:symbol
decode_space	instructions.cc	/^void decode_space( memory_space_t &space, ptx_thread_info *thread, const operand_info &op, memory_space *&mem, addr_t &addr)$/;"	f
decode_token	ptx_parser.cc	/^const char *decode_token( int type )$/;"	f
dimension	ptx_ir.h	/^   unsigned dimension() const { return m_geom_spec;}$/;"	f	class:ptx_instruction
directive_statement	ptx.y	/^directive_statement: variable_declaration SEMI_COLON$/;"	l
div_impl	instructions.cc	/^void div_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
dom	ptx_ir.h	/^   bool dom(const basic_block_t *B) {$/;"	f	struct:basic_block_t
dominator_ids	ptx_ir.h	/^   std::set<int> dominator_ids;$/;"	m	struct:basic_block_t
donecycle	ptx_sim.h	/^   unsigned donecycle() const { return m_cycle_done; }$/;"	f	class:ptx_thread_info
double_op_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
dram_traffic	ptx-stats.cc	/^    unsigned long long dram_traffic;$/;"	m	class:ptx_file_line_stats	file:
dst	ptx_ir.h	/^   const operand_info &dst() const $/;"	f	class:ptx_instruction
dst	ptx_ir.h	/^   operand_info &dst() $/;"	f	class:ptx_instruction
dump	ptx_ir.cc	/^void symbol_table::dump()$/;"	f	class:symbol_table
dump_callstack	ptx_sim.cc	/^void ptx_thread_info::dump_callstack() const$/;"	f	class:ptx_thread_info
dump_modifiedregs	ptx_sim.cc	/^void ptx_thread_info::dump_modifiedregs(FILE *fp)$/;"	f	class:ptx_thread_info
dump_regs	ptx_sim.cc	/^void ptx_thread_info::dump_regs( FILE *fp )$/;"	f	class:ptx_thread_info
enable_debug_trace	ptx_sim.h	/^   void enable_debug_trace() { m_enable_debug_trace = true; }$/;"	f	class:ptx_thread_info
enable_ptx_file_line_stats	ptx-stats.cc	/^bool enable_ptx_file_line_stats;$/;"	v
end_function	ptx_parser.cc	/^void end_function() $/;"	f
ex2_impl	instructions.cc	/^void ex2_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
exec_count	ptx-stats.cc	/^    unsigned long exec_count;$/;"	m	class:ptx_file_line_stats	file:
execute	cuda-sim.cc	/^void functionalCoreSim::execute()$/;"	f	class:functionalCoreSim
executeWarp	cuda-sim.cc	/^void functionalCoreSim::executeWarp(unsigned i, bool &allAtBarrier, bool & someOneLive)$/;"	f	class:functionalCoreSim
exitCore	ptx_sim.h	/^   void exitCore()$/;"	f	class:ptx_thread_info
exit_impl	instructions.cc	/^void exit_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
exposed_latency	ptx-stats.cc	/^    unsigned long long exposed_latency; \/\/ latency exposed as pipeline bubbles (attributed to this instruction)$/;"	m	class:ptx_file_line_stats	file:
extensions	ptx_sim.h	/^      unsigned extensions() const { assert(m_valid); return m_ptx_extensions; }$/;"	f	class:ptx_version
f16	ptx_sim.h	/^   float             f16; $/;"	m	union:ptx_reg_t
f2f	instructions.cc	/^ptx_reg_t f2f( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
f2x	instructions.cc	/^ptx_reg_t f2x( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
f32	ptx_sim.h	/^   float          f32;$/;"	m	union:ptx_reg_t
f64	ptx_sim.h	/^   double            f64;$/;"	m	union:ptx_reg_t
feature_not_implemented	ptx_sim.cc	/^void feature_not_implemented( const char *f ) $/;"	f
finalize	cuda-sim.cc	/^void function_info::finalize( memory_space *param_mem ) $/;"	f	class:function_info
find_break_target	ptx_ir.cc	/^operand_info* function_info::find_break_target( ptx_instruction * p_break_insn ) \/\/find the target of a break instruction $/;"	f	class:function_info
find_dominators	ptx_ir.cc	/^void function_info::find_dominators( )$/;"	f	class:function_info
find_idominators	ptx_ir.cc	/^void function_info::find_idominators( )$/;"	f	class:function_info
find_ipostdominators	ptx_ir.cc	/^void function_info::find_ipostdominators( )$/;"	f	class:function_info
find_next_real_instruction	ptx_ir.cc	/^std::list<ptx_instruction*>::iterator function_info::find_next_real_instruction( std::list<ptx_instruction*>::iterator i)$/;"	f	class:function_info
find_postdominators	ptx_ir.cc	/^void function_info::find_postdominators( )$/;"	f	class:function_info
find_reconvergence_points	cuda-sim.cc	/^struct rec_pts find_reconvergence_points( function_info *finfo )$/;"	f
float2	cuda-math.h	/^   struct float2 {$/;"	s	namespace:cuda_math
float2	cuda-math.h	/^   typedef struct float2 float2;$/;"	t	namespace:cuda_math	typeref:struct:cuda_math::float2
float2int	cuda-math.h	/^int float2int(float a, enum cudaRoundMode mode)$/;"	f	namespace:cuda_math
float2uint	cuda-math.h	/^unsigned int float2uint(float a, enum cudaRoundMode mode)$/;"	f	namespace:cuda_math
float4	cuda-math.h	/^   struct float4 {$/;"	s	namespace:cuda_math
float4	cuda-math.h	/^   typedef struct float4 float4;$/;"	t	namespace:cuda_math	typeref:struct:cuda_math::float4
float_op_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
floating_point_rounding_mode	ptx.y	/^floating_point_rounding_mode: RN_OPTION { add_option(RN_OPTION); } $/;"	l
fma_impl	instructions.cc	/^void fma_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
func_addr	ptx_ir.h	/^   const operand_info &func_addr() const$/;"	f	class:ptx_instruction
func_header	ptx_parser.cc	/^void func_header(const char* a) {} \/\/intentional dummy function$/;"	f
func_header_info	ptx_parser.cc	/^void func_header_info(const char* a) {} \/\/intentional dummy function$/;"	f
func_header_info_int	ptx_parser.cc	/^void func_header_info_int(const char* a, int b) {} \/\/intentional dummy function$/;"	f
func_info	ptx_sim.h	/^   function_info *func_info()$/;"	f	class:ptx_thread_info
function_decl	ptx.y	/^function_decl: function_decl_header LEFT_PAREN { start_function($1); func_header_info("(");} param_entry RIGHT_PAREN {func_header_info(")");} function_ident_param { $$ = reset_symtab(); }$/;"	l
function_decl_header	ptx.y	/^function_decl_header: ENTRY_DIRECTIVE { $$ = 1; g_func_decl=1; func_header(".entry"); }$/;"	l
function_defn	ptx.y	/^function_defn: function_decl { set_symtab($1); func_header(".skip"); } statement_block { end_function(); }$/;"	l
function_ident_param	ptx.y	/^function_ident_param: IDENTIFIER { add_function_name($1); } LEFT_PAREN {func_header_info("(");} param_list RIGHT_PAREN { g_func_decl=0; func_header_info(")"); } $/;"	l
function_info	ptx_ir.cc	/^function_info::function_info(int entry_point ) $/;"	f	class:function_info
function_info	ptx_ir.h	/^class function_info {$/;"	c
function_info	ptxinfo.y	/^function_info: info$/;"	l
function_name	ptxinfo.y	/^function_name: FUNC QUOTE IDENTIFIER QUOTE { ptxinfo_function($3); }$/;"	l
functionalCoreSim	cuda-sim.h	/^    functionalCoreSim(kernel_info_t * kernel, gpgpu_sim *g, unsigned warp_size)$/;"	f	class:functionalCoreSim
functionalCoreSim	cuda-sim.h	/^class functionalCoreSim: public core_t$/;"	c
g_add_identifier_cached__array_dim	ptx_parser.cc	/^int g_add_identifier_cached__array_dim;$/;"	v
g_add_identifier_cached__array_ident	ptx_parser.cc	/^int g_add_identifier_cached__array_ident;$/;"	v
g_add_identifier_cached__identifier	ptx_parser.cc	/^char *g_add_identifier_cached__identifier = NULL;$/;"	v
g_alignment_spec	ptx_parser.cc	/^int g_alignment_spec = -1;$/;"	v
g_assemble_code_next_pc	cuda-sim.cc	/^unsigned g_assemble_code_next_pc=0; $/;"	v
g_const_alloc	ptx_parser.cc	/^unsigned g_const_alloc = 1;$/;"	v
g_const_name_lookup	cuda-sim.cc	/^std::map<const void*,std::string>   g_const_name_lookup; \/\/ indexed by hostVar$/;"	v
g_constants	cuda-sim.cc	/^std::set<std::string>   g_constants;$/;"	v
g_cuda_launch_blocking	cuda-sim.cc	/^bool g_cuda_launch_blocking = false;$/;"	v
g_current_symbol_table	ptx_parser.cc	/^static symbol_table *g_current_symbol_table = NULL;$/;"	v	file:
g_cvt_fn	instructions.cc	/^ptx_reg_t (*g_cvt_fn[11][11])( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, $/;"	v
g_debug_execution	cuda-sim.cc	/^int g_debug_execution = 0;$/;"	v
g_debug_ir_generation	ptx_parser.cc	/^static bool g_debug_ir_generation=false;$/;"	v	file:
g_debug_pc	cuda-sim.cc	/^addr_t g_debug_pc = 0xBEEF1518;$/;"	v
g_debug_thread_uid	cuda-sim.cc	/^int g_debug_thread_uid = 0;$/;"	v
g_entry_func_param_index	ptx_parser.cc	/^static unsigned g_entry_func_param_index=0;$/;"	v	file:
g_entry_point	ptx_parser.cc	/^static int g_entry_point;$/;"	v	file:
g_error_detected	ptx_parser.cc	/^int g_error_detected = 0;$/;"	v
g_extern_spec	ptx_parser.cc	/^int g_extern_spec = 0;$/;"	v
g_filename	ptx_parser.cc	/^const char *g_filename;$/;"	v
g_func_cta_info	cuda-sim.cc	/^ptx_cta_info *g_func_cta_info = NULL;$/;"	v
g_func_decl	ptx_parser.cc	/^int g_func_decl = 0;$/;"	v
g_func_info	ptx_parser.cc	/^static function_info *g_func_info = NULL;$/;"	v	file:
g_global_allfiles_symbol_table	ptx_parser.cc	/^static symbol_table *g_global_allfiles_symbol_table = NULL;$/;"	v	file:
g_global_mem	ptx_loader.cc	/^memory_space *g_global_mem;$/;"	v
g_global_name_lookup	cuda-sim.cc	/^std::map<const void*,std::string>   g_global_name_lookup; \/\/ indexed by hostVar$/;"	v
g_global_symbol_table	ptx_parser.cc	/^static symbol_table *g_global_symbol_table = NULL;$/;"	v	file:
g_globals	cuda-sim.cc	/^std::set<std::string>   g_globals;$/;"	v
g_ident_add_uid	ptx_parser.cc	/^int g_ident_add_uid = 0;$/;"	v
g_inst_classification_stat	cuda-sim.cc	/^void ** g_inst_classification_stat = NULL;$/;"	v
g_inst_lookup	ptx_parser.cc	/^std::map<std::string,std::map<unsigned,const ptx_instruction*> > g_inst_lookup;$/;"	v
g_inst_op_classification_stat	cuda-sim.cc	/^void ** g_inst_op_classification_stat= NULL;$/;"	v
g_instructions	ptx_parser.cc	/^static std::list<ptx_instruction*> g_instructions;$/;"	v	file:
g_keep_intermediate_files	ptx_loader.cc	/^bool g_keep_intermediate_files;$/;"	v
g_label	ptx_parser.cc	/^symbol *g_label;$/;"	v
g_last_symbol	ptx_parser.cc	/^static symbol *g_last_symbol = NULL;$/;"	v	file:
g_max_regs_per_thread	ptx_parser.cc	/^unsigned g_max_regs_per_thread = 0;$/;"	v
g_neg_pred	ptx_parser.cc	/^int g_neg_pred;$/;"	v
g_num_ptx_inst_uid	instructions.cc	/^unsigned ptx_instruction::g_num_ptx_inst_uid=0;$/;"	m	class:ptx_instruction	file:
g_num_ptx_inst_uid	ptx_ir.h	/^   static unsigned g_num_ptx_inst_uid;$/;"	m	class:ptx_instruction
g_opcode	ptx_parser.cc	/^int g_opcode = -1;$/;"	v
g_opcode_string	instructions.cc	/^const char *g_opcode_string[NUM_OPCODES] = {$/;"	v
g_operands	ptx_parser.cc	/^std::list<operand_info> g_operands;$/;"	v
g_options	ptx_parser.cc	/^std::list<int> g_options;$/;"	v
g_override_embedded_ptx	ptx_loader.cc	/^bool g_override_embedded_ptx = false;$/;"	v
g_param_mem	ptx_loader.cc	/^memory_space *g_param_mem;$/;"	v
g_pc_to_finfo	cuda-sim.cc	/^std::map<unsigned,function_info*> g_pc_to_finfo;$/;"	v
g_pred	ptx_parser.cc	/^const symbol *g_pred;$/;"	v
g_pred_mod	ptx_parser.cc	/^int g_pred_mod;$/;"	v
g_print_memory_space	memory.cc	/^void g_print_memory_space(memory_space *mem, const char *format = "%08x", FILE *fout = stdout) $/;"	f
g_ptr_spec	ptx_parser.cc	/^memory_space_t g_ptr_spec = undefined_space;$/;"	v
g_ptx_cta_info_sm_idx_used	ptx_sim.cc	/^std::set<unsigned long long> g_ptx_cta_info_sm_idx_used;$/;"	v
g_ptx_cta_info_uid	ptx_sim.cc	/^unsigned long long g_ptx_cta_info_uid = 1;$/;"	v
g_ptx_kernel_count	cuda-sim.cc	/^int g_ptx_kernel_count = -1; \/\/ used for classification stat collection purposes $/;"	v
g_ptx_sim_mode	cuda-sim.cc	/^int g_ptx_sim_mode; \/\/ if non-zero run functional simulation only (i.e., no notion of a clock cycle)$/;"	v
g_ptx_sim_num_insn	cuda-sim.cc	/^unsigned g_ptx_sim_num_insn = 0;$/;"	v
g_ptx_thread_info_delete_count	ptx_sim.cc	/^unsigned g_ptx_thread_info_delete_count=0;$/;"	v
g_ptx_thread_info_uid_next	ptx_sim.cc	/^unsigned g_ptx_thread_info_uid_next=1;$/;"	v
g_ptx_token_decode	ptx_parser.cc	/^static std::map<unsigned,std::string> g_ptx_token_decode;$/;"	v	file:
g_ptxinfo_error_detected	cuda-sim.cc	/^int g_ptxinfo_error_detected;$/;"	v
g_ptxinfo_filename	ptx_loader.cc	/^const char *g_ptxinfo_filename;$/;"	v
g_ptxinfo_kinfo	cuda-sim.cc	/^static struct gpgpu_ptx_sim_kernel_info g_ptxinfo_kinfo;$/;"	v	typeref:struct:gpgpu_ptx_sim_kernel_info	file:
g_ptxinfo_kname	cuda-sim.cc	/^static char *g_ptxinfo_kname = NULL;$/;"	v	file:
g_return_var	ptx_parser.cc	/^static operand_info g_return_var;$/;"	v	file:
g_rpts	cuda-sim.cc	/^struct std::map<function_info*,rec_pts> g_rpts;$/;"	v	typeref:struct:map
g_save_embedded_ptx	ptx_loader.cc	/^static bool g_save_embedded_ptx;$/;"	v	file:
g_scalar_type	ptx_parser.cc	/^std::list<int> g_scalar_type;$/;"	v
g_scalar_type_spec	ptx_parser.cc	/^int g_scalar_type_spec = -1;$/;"	v
g_shader_core_config	ptx_parser.cc	/^static const struct core_config *g_shader_core_config;$/;"	v	typeref:struct:core_config	file:
g_space_spec	ptx_parser.cc	/^memory_space_t g_space_spec = undefined_space;$/;"	v
g_surf_mem	ptx_loader.cc	/^memory_space *g_surf_mem;$/;"	v
g_sym_name_to_symbol_table	ptx_parser.cc	/^std::map<std::string,symbol_table*> g_sym_name_to_symbol_table;$/;"	v
g_tex_mem	ptx_loader.cc	/^memory_space *g_tex_mem;$/;"	v
g_var_type	ptx_parser.cc	/^type_info *g_var_type = NULL;$/;"	v
g_vector_spec	ptx_parser.cc	/^int g_vector_spec = -1;$/;"	v
generic_to_global	cuda-sim.cc	/^addr_t generic_to_global( addr_t addr )$/;"	f
generic_to_local	cuda-sim.cc	/^addr_t generic_to_local( unsigned smid, unsigned hwtid, addr_t addr )$/;"	f
generic_to_shared	cuda-sim.cc	/^addr_t generic_to_shared( unsigned smid, addr_t addr )$/;"	f
get_PC	ptx_ir.h	/^   addr_t get_PC() const$/;"	f	class:ptx_instruction
get_addr_offset	ptx_ir.h	/^   int get_addr_offset() const { return m_addr_offset;}$/;"	f	class:operand_info
get_addr_space	ptx_ir.h	/^   enum _memory_space_t get_addr_space() const { return m_addr_space; }$/;"	f	class:operand_info
get_address	ptx_ir.h	/^   addr_t get_address() const $/;"	f	class:symbol
get_arg	ptx_ir.h	/^   const symbol* get_arg( unsigned n ) const$/;"	f	class:function_info
get_array_dim	ptx_ir.h	/^   int get_array_dim() const { assert(m_init); return m_array_dim; }$/;"	f	class:type_info_key
get_array_type	ptx_ir.cc	/^type_info *symbol_table::get_array_type( type_info *base_type, unsigned array_dim ) $/;"	f	class:symbol_table
get_atomic	ptx_ir.h	/^   unsigned get_atomic() const { return m_atomic_spec;}$/;"	f	class:ptx_instruction
get_bb	ptx_ir.h	/^   basic_block_t* get_bb() { return m_basic_block;}$/;"	f	class:ptx_instruction
get_bit	ptx_sim.h	/^   int get_bit( unsigned bit )$/;"	f	union:ptx_reg_t
get_builtin	ptx_sim.cc	/^unsigned ptx_thread_info::get_builtin( int builtin_id, unsigned dim_mod ) $/;"	f	class:ptx_thread_info
get_cmpop	ptx_ir.h	/^   unsigned get_cmpop() const { return m_compare_op;}$/;"	f	class:ptx_instruction
get_config	ptx_sim.h	/^   const gpgpu_functional_sim_config &get_config() const { return m_gpu->get_config(); }$/;"	f	class:ptx_thread_info
get_const_mem_offset	ptx_ir.h	/^   addr_t get_const_mem_offset() const { return m_const_mem_offset; }$/;"	f	class:operand_info
get_converge_point	cuda-sim.cc	/^address_type get_converge_point( address_type pc ) $/;"	f
get_core	ptx_sim.h	/^   core_t *get_core() { return m_core; }$/;"	f	class:ptx_thread_info
get_cta_uid	ptx_sim.h	/^   unsigned long long get_cta_uid() { return m_cta_info->get_sm_idx();}$/;"	f	class:ptx_thread_info
get_ctaid	ptx_sim.h	/^   dim3 get_ctaid() const { return m_ctaid; }$/;"	f	class:ptx_thread_info
get_double_operand_type	ptx_ir.h	/^   int get_double_operand_type() const { return  m_double_operand_type; }$/;"	f	class:operand_info
get_dst	ptx_ir.h	/^   const symbol *get_dst() const { return m_dst; }$/;"	f	class:arg_buffer_t
get_finfo	ptx_sim.h	/^   const function_info *get_finfo() const { return m_func_info;   }$/;"	f	class:ptx_thread_info
get_finfo	ptx_sim.h	/^   function_info *get_finfo() { return m_func_info;   }$/;"	f	class:ptx_thread_info
get_function_size	ptx_ir.h	/^   unsigned get_function_size() { return m_instructions.size();}$/;"	f	class:function_info
get_global_memory	ptx_sim.h	/^   memory_space *get_global_memory() { return m_gpu->get_global_memory(); }$/;"	f	class:ptx_thread_info
get_global_next	ptx_ir.h	/^   addr_t get_global_next() { return m_global_next;}$/;"	f	class:symbol_table
get_gpu	ptx_sim.h	/^   class gpgpu_sim *get_gpu() { return (gpgpu_sim*)m_gpu;}$/;"	f	class:ptx_thread_info
get_hw_ctaid	ptx_sim.h	/^   unsigned get_hw_ctaid() const { return m_hw_ctaid;}$/;"	f	class:ptx_thread_info
get_hw_sid	ptx_sim.h	/^   unsigned get_hw_sid() const { return m_hw_sid;}$/;"	f	class:ptx_thread_info
get_hw_tid	ptx_sim.h	/^   unsigned get_hw_tid() const { return m_hw_tid;}$/;"	f	class:ptx_thread_info
get_hw_wid	ptx_sim.h	/^   unsigned get_hw_wid() const { return m_hw_wid;}$/;"	f	class:ptx_thread_info
get_icount	ptx_sim.h	/^   unsigned get_icount() const { return m_icount;}$/;"	f	class:ptx_thread_info
get_initializer	ptx_ir.h	/^   std::list<operand_info> get_initializer() const$/;"	f	class:symbol
get_insn_str	ptx_ir.cc	/^std::string function_info::get_insn_str( unsigned pc ) const$/;"	f	class:function_info
get_inst	ptx_sim.cc	/^const ptx_instruction *ptx_thread_info::get_inst( addr_t pc ) const$/;"	f	class:ptx_thread_info
get_inst	ptx_sim.cc	/^const ptx_instruction *ptx_thread_info::get_inst() const$/;"	f	class:ptx_thread_info
get_instruction	ptx_ir.h	/^   const ptx_instruction *get_instruction( unsigned PC ) const$/;"	f	class:function_info
get_int	ptx_ir.h	/^   int get_int() const { return m_value.m_int;}$/;"	f	class:operand_info
get_kernel_code_size	cuda-sim.cc	/^size_t get_kernel_code_size( class function_info *entry )$/;"	f
get_kernel_info	ptx_ir.h	/^   const struct gpgpu_ptx_sim_kernel_info* get_kernel_info () const$/;"	f	class:function_info
get_key	ptx_ir.h	/^   const type_info_key &get_key() const { return m_type_info;}$/;"	f	class:type_info
get_label	ptx_ir.h	/^   const symbol *get_label() const { return m_label;}$/;"	f	class:ptx_instruction
get_literal_value	ptx_ir.h	/^   ptx_reg_t get_literal_value() const$/;"	f	class:operand_info
get_local_mem_stack_pointer	ptx_sim.h	/^   unsigned get_local_mem_stack_pointer() const { return m_local_mem_stack_pointer; }$/;"	f	class:ptx_thread_info
get_local_next	ptx_ir.h	/^   addr_t get_local_next() { return m_local_next;}$/;"	f	class:symbol_table
get_location	ptx_sim.cc	/^std::string ptx_thread_info::get_location() const$/;"	f	class:ptx_thread_info
get_m_instr_mem_index	ptx_ir.h	/^   unsigned get_m_instr_mem_index() { return m_instr_mem_index;}$/;"	f	class:ptx_instruction
get_memory_space	ptx_ir.h	/^   memory_space_t get_memory_space() const { return m_space_spec; }$/;"	f	class:type_info_key
get_name	ptx_ir.h	/^   std::string get_name() const { assert(m_valid); return m_name; }$/;"	f	class:param_info
get_name	ptx_ir.h	/^   std::string get_name() const$/;"	f	class:function_info
get_num_operands	ptx_ir.h	/^   unsigned get_num_operands() const { return m_operands.size();}$/;"	f	class:ptx_instruction
get_num_reconvergence_pairs	ptx_ir.cc	/^unsigned function_info::get_num_reconvergence_pairs()$/;"	f	class:function_info
get_offset	ptx_ir.h	/^   unsigned get_offset() { assert(m_valid); return m_offset; }$/;"	f	class:param_info
get_opcode	ptx_ir.h	/^   int get_opcode() const { return m_opcode;}$/;"	f	class:ptx_instruction
get_opcode_cstr	ptx_ir.h	/^   const char *get_opcode_cstr() const $/;"	f	class:ptx_instruction
get_operand_lohi	ptx_ir.h	/^   int get_operand_lohi() const { return m_operand_lohi; }$/;"	f	class:operand_info
get_operand_nbits	instructions.cc	/^unsigned get_operand_nbits( const operand_info &op )$/;"	f
get_operand_neg	ptx_ir.h	/^   bool get_operand_neg() const { return m_operand_neg; }$/;"	f	class:operand_info
get_operand_value	instructions.cc	/^ptx_reg_t ptx_thread_info::get_operand_value( const operand_info &op, operand_info dstInfo, unsigned opType, ptx_thread_info *thread, int derefFlag )$/;"	f	class:ptx_thread_info
get_param_buffer	ptx_ir.h	/^   const void *get_param_buffer() const$/;"	f	class:arg_buffer_t
get_param_buffer_size	ptx_ir.h	/^   size_t get_param_buffer_size() const$/;"	f	class:arg_buffer_t
get_param_memory	ptx_sim.h	/^   memory_space *get_param_memory() { return m_kernel.get_param_memory(); }$/;"	f	class:ptx_thread_info
get_pc	ptx_ir.h	/^   function_info *get_pc() const$/;"	f	class:symbol
get_pc	ptx_sim.h	/^   unsigned get_pc() const$/;"	f	class:ptx_thread_info
get_pred	ptx_ir.h	/^   operand_info get_pred() const { return operand_info( m_pred );}$/;"	f	class:ptx_instruction
get_pred_mod	ptx_ir.h	/^   int get_pred_mod() const { return m_pred_mod;}$/;"	f	class:ptx_instruction
get_pred_neg	ptx_ir.h	/^   bool get_pred_neg() const { return m_neg_pred;}$/;"	f	class:ptx_instruction
get_ptx_version	ptx_ir.cc	/^const ptx_version &symbol_table::get_ptx_version() const $/;"	f	class:symbol_table
get_ptx_version	ptx_ir.h	/^   const ptx_version &get_ptx_version() const { return m_symtab->get_ptx_version(); }$/;"	f	class:function_info
get_ptx_version	ptx_sim.cc	/^const ptx_version &ptx_thread_info::get_ptx_version() const $/;"	f	class:ptx_thread_info
get_ptxinfo_kinfo	cuda-sim.cc	/^struct gpgpu_ptx_sim_kernel_info get_ptxinfo_kinfo()$/;"	f
get_ptxinfo_kname	cuda-sim.cc	/^const char *get_ptxinfo_kname() $/;"	f
get_reconvergence_pairs	ptx_ir.cc	/^void function_info::get_reconvergence_pairs(gpgpu_recon_t* recon_points)$/;"	f	class:function_info
get_reg	instructions.cc	/^ptx_reg_t ptx_thread_info::get_reg( const symbol *reg )$/;"	f	class:ptx_thread_info
get_reg	ptx_ir.h	/^   ptx_reg_t get_reg() const $/;"	f	class:arg_buffer_t
get_return_PC	ptx_sim.h	/^   unsigned get_return_PC()$/;"	f	class:ptx_thread_info
get_return_pc	cuda-sim.cc	/^address_type get_return_pc( void *thd )$/;"	f
get_return_var	ptx_ir.h	/^   const symbol *get_return_var() const$/;"	f	class:function_info
get_rpc	ptx_sim.h	/^   unsigned get_rpc() const { return m_RPC; }$/;"	f	class:ptx_thread_info
get_scope_name	ptx_ir.h	/^   std::string get_scope_name() const { return m_scope_name; }$/;"	f	class:symbol_table
get_shared_next	ptx_ir.h	/^   addr_t get_shared_next() { return m_shared_next;}$/;"	f	class:symbol_table
get_size	ptx_ir.h	/^   size_t get_size() const { assert(m_valid); return m_size; }$/;"	f	class:param_info
get_size_in_bytes	ptx_ir.h	/^   unsigned get_size_in_bytes() const$/;"	f	class:symbol
get_sm_idx	ptx_sim.cc	/^unsigned ptx_cta_info::get_sm_idx() const$/;"	f	class:ptx_cta_info
get_sm_target	ptx_ir.cc	/^unsigned symbol_table::get_sm_target() const $/;"	f	class:symbol_table
get_sm_target	ptx_ir.h	/^   unsigned get_sm_target() const { return m_symtab->get_sm_target(); }$/;"	f	class:function_info
get_source	ptx_ir.h	/^   const char *get_source() const { return m_source.c_str();}$/;"	f	class:ptx_instruction
get_space	ptx_ir.h	/^   memory_space_t get_space() const { return m_space_spec;}$/;"	f	class:ptx_instruction
get_start_PC	ptx_ir.h	/^   addr_t get_start_PC() const$/;"	f	class:function_info
get_surf_memory	ptx_sim.h	/^   memory_space *get_surf_memory() { return m_gpu->get_surf_memory(); }$/;"	f	class:ptx_thread_info
get_symbol	ptx_ir.h	/^   const symbol *get_symbol() const { return m_value.m_symbolic;}$/;"	f	class:operand_info
get_symtab	ptx_ir.h	/^   symbol_table *get_symtab()$/;"	f	class:function_info
get_tex_datasize	cuda-sim.cc	/^static unsigned get_tex_datasize( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f	file:
get_tex_memory	ptx_sim.h	/^   memory_space *get_tex_memory() { return m_gpu->get_tex_memory(); }$/;"	f	class:ptx_thread_info
get_tex_next	ptx_ir.h	/^   addr_t get_tex_next() { return m_tex_next;}$/;"	f	class:symbol_table
get_tid	ptx_sim.h	/^   dim3 get_tid() const { return m_tid; }$/;"	f	class:ptx_thread_info
get_type	ptx_ir.h	/^   enum operand_type get_type() const {$/;"	f	class:operand_info
get_type	ptx_ir.h	/^   int get_type() const $/;"	f	class:ptx_instruction
get_type	ptx_ir.h	/^   int get_type() const { assert(m_valid);  return m_type; }$/;"	f	class:param_info
get_type2	ptx_ir.h	/^   int get_type2() const $/;"	f	class:ptx_instruction
get_uid	ptx_ir.cc	/^unsigned operand_info::get_uid()$/;"	f	class:operand_info
get_uid	ptx_ir.cc	/^unsigned symbol::get_uid()$/;"	f	class:symbol
get_uid	ptx_sim.h	/^   unsigned get_uid() const$/;"	f	class:ptx_thread_info
get_value	ptx_ir.h	/^   param_t get_value() const { assert(m_value_set); return m_value; }$/;"	f	class:param_info
get_vect_nelem	ptx_ir.h	/^   unsigned get_vect_nelem() const$/;"	f	class:operand_info
get_vector	ptx_ir.h	/^   unsigned get_vector() const { return m_vector_spec;}$/;"	f	class:ptx_instruction
get_vector_operand_values	instructions.cc	/^void ptx_thread_info::get_vector_operand_values( const operand_info &op, ptx_reg_t* ptx_regs, unsigned num_elements )$/;"	f	class:ptx_thread_info
global_iterator_begin	ptx_ir.h	/^   iterator global_iterator_begin() { return m_globals.begin();}$/;"	f	class:symbol_table
global_iterator_end	ptx_ir.h	/^   iterator global_iterator_end() { return m_globals.end();}$/;"	f	class:symbol_table
global_to_generic	cuda-sim.cc	/^addr_t global_to_generic( addr_t addr )$/;"	f
gmem_n_access_total	ptx-stats.cc	/^    unsigned long long gmem_n_access_total; \/\/ number of uncoalesced access in total from this instruction$/;"	m	class:ptx_file_line_stats	file:
gmem_warp_count	ptx-stats.cc	/^    unsigned long gmem_warp_count;          \/\/ number of warps causing these uncoalesced access$/;"	m	class:ptx_file_line_stats	file:
gpgpu_cuda_ptx_sim_main_func	cuda-sim.cc	/^void gpgpu_cuda_ptx_sim_main_func( kernel_info_t &kernel, bool openCL )$/;"	f
gpgpu_opencl_ptx_sim_init_grid	cuda-sim.cc	/^kernel_info_t *gpgpu_opencl_ptx_sim_init_grid(class function_info *entry,$/;"	f
gpgpu_param_num_shaders	cuda-sim.cc	/^unsigned gpgpu_param_num_shaders = 0;$/;"	v
gpgpu_ptx_assemble	ptx_ir.cc	/^void gpgpu_ptx_assemble( std::string kname, void *kinfo )$/;"	f
gpgpu_ptx_instruction_classification	cuda-sim.cc	/^int gpgpu_ptx_instruction_classification;$/;"	v
gpgpu_ptx_sim_bindNameToTexture	cuda-sim.cc	/^void gpgpu_t::gpgpu_ptx_sim_bindNameToTexture(const char* name, const struct textureReference* texref, int dim, int readmode, int ext)$/;"	f	class:gpgpu_t
gpgpu_ptx_sim_bindTextureToArray	cuda-sim.cc	/^void gpgpu_t::gpgpu_ptx_sim_bindTextureToArray(const struct textureReference* texref, const struct cudaArray* array)$/;"	f	class:gpgpu_t
gpgpu_ptx_sim_convert_ptx_and_sass_to_ptxplus	ptx_loader.cc	/^char* gpgpu_ptx_sim_convert_ptx_and_sass_to_ptxplus(const std::string ptxfilename, const std::string elffilename, const std::string sassfilename)$/;"	f
gpgpu_ptx_sim_findNamefromTexture	cuda-sim.cc	/^const char* gpgpu_t::gpgpu_ptx_sim_findNamefromTexture(const struct textureReference* texref)$/;"	f	class:gpgpu_t
gpgpu_ptx_sim_load_ptx_from_string	ptx_loader.cc	/^symbol_table *gpgpu_ptx_sim_load_ptx_from_string( const char *p, unsigned source_num )$/;"	f
gpgpu_ptx_sim_memcpy_symbol	cuda-sim.cc	/^void gpgpu_ptx_sim_memcpy_symbol(const char *hostVar, const void *src, size_t count, size_t offset, int to, gpgpu_t *gpu )$/;"	f
gpgpu_ptx_sim_register_const_variable	cuda-sim.cc	/^void gpgpu_ptx_sim_register_const_variable(void *hostVar, const char *deviceName, size_t size )$/;"	f
gpgpu_ptx_sim_register_global_variable	cuda-sim.cc	/^void gpgpu_ptx_sim_register_global_variable(void *hostVar, const char *deviceName, size_t size )$/;"	f
gpgpu_ptxinfo_load_from_string	ptx_loader.cc	/^void gpgpu_ptxinfo_load_from_string( const char *p_for_info, unsigned source_num )$/;"	f
gpgpu_recon_t	ptx_ir.h	/^struct gpgpu_recon_t {$/;"	s
gpgpusim_cuda_vprintf	cuda_device_printf.cc	/^void gpgpusim_cuda_vprintf(const ptx_instruction * pI, ptx_thread_info * thread, const function_info * target_func ) $/;"	f
gpu_malloc	cuda-sim.cc	/^void* gpgpu_t::gpu_malloc( size_t size )$/;"	f	class:gpgpu_t
gpu_mallocarray	cuda-sim.cc	/^void* gpgpu_t::gpu_mallocarray( size_t size )$/;"	f	class:gpgpu_t
gpu_memset	cuda-sim.cc	/^void gpgpu_t::gpu_memset( size_t dst_start_addr, int c, size_t count )$/;"	f	class:gpgpu_t
has_initializer	ptx_ir.h	/^   bool has_initializer() const $/;"	f	class:symbol
has_memory_read	ptx_ir.h	/^   bool has_memory_read() const {$/;"	f	class:ptx_instruction
has_memory_write	ptx_ir.h	/^   bool has_memory_write() const {$/;"	f	class:ptx_instruction
has_pred	ptx_ir.h	/^   bool has_pred() const { return m_pred != NULL;}$/;"	f	class:ptx_instruction
has_return	ptx_ir.h	/^   bool has_return() const$/;"	f	class:function_info
has_return	ptx_ir.h	/^   bool has_return() const$/;"	f	class:ptx_instruction
hash_ptx_file_line	ptx-stats.cc	/^struct hash_ptx_file_line$/;"	s	file:
high	ptx_sim.h	/^       unsigned int high;$/;"	m	struct:ptx_reg_t::__anon2
highest	ptx_sim.h	/^       unsigned int highest;$/;"	m	struct:ptx_reg_t::__anon2
identifier_list	ptx.y	/^identifier_list: identifier_spec$/;"	l
identifier_spec	ptx.y	/^identifier_spec: IDENTIFIER { add_identifier($1,0,NON_ARRAY_IDENTIFIER); func_header_info($1);}$/;"	l
immediatedominator_id	ptx_ir.h	/^   int immediatedominator_id;$/;"	m	struct:basic_block_t
immediatepostdominator_id	ptx_ir.h	/^   int immediatepostdominator_id;$/;"	m	struct:basic_block_t
inflight_mem_tracker	ptx-stats.cc	/^static ptx_inflight_memory_insn_tracker *inflight_mem_tracker = NULL;$/;"	v	file:
info	ptxinfo.y	/^info: 	  USED INT_OPERAND REGS { ptxinfo_regs($2); }$/;"	l
init	ptx_ir.h	/^   void init()$/;"	f	class:operand_info
init	ptx_sim.h	/^   void init(gpgpu_t *gpu, core_t *core, unsigned sid, unsigned cta_id, unsigned wid, unsigned tid, bool fsim) $/;"	f	class:ptx_thread_info
init_directive_state	ptx_parser.cc	/^void init_directive_state()$/;"	f
init_inst_classification_stat	cuda-sim.cc	/^void init_inst_classification_stat() $/;"	f
init_instruction_state	ptx_parser.cc	/^void init_instruction_state()$/;"	f
init_parser	ptx_parser.cc	/^symbol_table *init_parser( const char *ptx_filename )$/;"	f
initializeCTA	cuda-sim.cc	/^void functionalCoreSim::initializeCTA()$/;"	f	class:functionalCoreSim
initializer_list	ptx.y	/^initializer_list: LEFT_BRACE literal_list RIGHT_BRACE { add_array_initializer(); } $/;"	l
input	ptx.y	/^input:	\/* empty *\/$/;"	l
input	ptxinfo.y	/^input:	\/* empty *\/$/;"	l
insn_count_map	ptx-stats.cc	/^    typedef std::map<const ptx_instruction *, int> insn_count_map;$/;"	t	class:ptx_inflight_memory_insn_tracker	file:
inst_not_implemented	instructions.cc	/^void inst_not_implemented( const ptx_instruction * pI ) $/;"	f
inst_size	ptx_ir.h	/^   unsigned inst_size() const { return m_inst_size; }$/;"	f	class:ptx_instruction
instruction	ptx.y	/^instruction: opcode_spec LEFT_PAREN operand RIGHT_PAREN { set_return(); } COMMA operand COMMA LEFT_PAREN operand_list RIGHT_PAREN$/;"	l
instruction_statement	ptx.y	/^instruction_statement:  instruction SEMI_COLON$/;"	l
int4	cuda-math.h	/^   struct int4 {$/;"	s	namespace:cuda_math
int4	cuda-math.h	/^   typedef struct int4 int4;$/;"	t	namespace:cuda_math	typeref:struct:cuda_math::int4
intLOGB2	cuda-sim.cc	/^unsigned int intLOGB2( unsigned int v ) {$/;"	f
int_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
integer_rounding_mode	ptx.y	/^integer_rounding_mode: RNI_OPTION { add_option(RNI_OPTION); } $/;"	l
intersect	ptx_ir.cc	/^void intersect( std::set<int> &A, const std::set<int> &B )$/;"	f
intfloat	instructions.cc	/^union intfloat {$/;"	u	file:
isFloat	instructions.cc	/^bool isFloat(int type) $/;"	f
isInFunctionalSimulationMode	ptx_sim.h	/^   bool isInFunctionalSimulationMode(){ return m_functionalSimulationMode;}$/;"	f	class:ptx_thread_info
isNaN	instructions.cc	/^bool isNaN(double x)$/;"	f
isNaN	instructions.cc	/^bool isNaN(float x)$/;"	f
is_abs	ptx_ir.h	/^   bool is_abs() const { return m_abs;}$/;"	f	class:ptx_instruction
is_builtin	ptx_ir.h	/^   bool is_builtin() const { return m_type == builtin_t;}$/;"	f	class:operand_info
is_const	ptx_ir.h	/^   bool is_const() const { return m_is_const;}$/;"	f	class:symbol
is_const	ptx_ir.h	/^   bool is_const() const { return m_space_spec.get_type() == const_space;}$/;"	f	class:type_info_key
is_const	ptx_ir.h	/^   bool is_const() const { return m_value.m_symbolic->is_const();}$/;"	f	class:operand_info
is_done	ptx_sim.h	/^   bool is_done() { return m_thread_done;}$/;"	f	class:ptx_thread_info
is_entry	ptx_ir.h	/^   bool is_entry;$/;"	m	struct:basic_block_t
is_entry_point	ptx_ir.h	/^   bool is_entry_point() const { return m_entry_point; }$/;"	f	class:function_info
is_equal	ptx_ir.cc	/^bool is_equal( const std::set<int> &A, const std::set<int> &B )$/;"	f
is_exit	ptx_ir.h	/^   bool is_exit() const { return m_exit;}$/;"	f	class:ptx_instruction
is_exit	ptx_ir.h	/^   bool is_exit;$/;"	m	struct:basic_block_t
is_extern	ptx_ir.h	/^   bool is_extern() const { return m_extern; }$/;"	f	class:function_info
is_func_addr	ptx_ir.h	/^   bool is_func_addr() const { return m_is_func_addr; }$/;"	f	class:symbol
is_func_addr	ptx_ir.h	/^   bool is_func_addr() const { return m_is_function?true:false; }$/;"	f	class:type_info_key
is_function_address	ptx_ir.h	/^   bool is_function_address() const$/;"	f	class:operand_info
is_global	ptx_ir.h	/^   bool is_global() const { return m_is_global;}$/;"	f	class:symbol
is_global	ptx_ir.h	/^   bool is_global() const { return m_space_spec == global_space;}$/;"	f	class:type_info_key
is_global	ptx_ir.h	/^   bool is_global() const { return m_value.m_symbolic->is_global();}$/;"	f	class:operand_info
is_hi	ptx_ir.h	/^   bool is_hi() const { return m_hi;}$/;"	f	class:ptx_instruction
is_immediate_address	ptx_ir.h	/^   bool is_immediate_address() const {$/;"	f	class:operand_info
is_label	ptx_ir.h	/^   bool is_label() const { if(m_label){ assert(m_opcode==-1);return true;} return false;}$/;"	f	class:ptx_instruction
is_label	ptx_ir.h	/^   bool is_label() const { return m_is_label;}$/;"	f	class:symbol
is_label	ptx_ir.h	/^   bool is_label() const { return m_type == label_t;}$/;"	f	class:operand_info
is_literal	ptx_ir.h	/^   bool is_literal() const { return m_type == int_t ||$/;"	f	class:operand_info
is_lo	ptx_ir.h	/^   bool is_lo() const { return m_lo;}$/;"	f	class:ptx_instruction
is_local	ptx_ir.h	/^   bool is_local() const { return m_is_local;}$/;"	f	class:symbol
is_local	ptx_ir.h	/^   bool is_local() const { return m_space_spec == local_space;}$/;"	f	class:type_info_key
is_local	ptx_ir.h	/^   bool is_local() const { return m_value.m_symbolic->is_local();}$/;"	f	class:operand_info
is_memory_operand	ptx_ir.h	/^   bool is_memory_operand() const { return m_type == memory_t;}$/;"	f	class:operand_info
is_memory_operand2	ptx_ir.h	/^   bool is_memory_operand2() const { $/;"	f	class:operand_info
is_neg	ptx_ir.h	/^   bool is_neg() const { return m_neg;}$/;"	f	class:ptx_instruction
is_neg_pred	ptx_ir.h	/^   bool is_neg_pred() const { return m_neg_pred; }$/;"	f	class:operand_info
is_non_arch_reg	ptx_ir.h	/^   bool is_non_arch_reg() const { return m_is_non_arch_reg; }$/;"	f	class:operand_info
is_non_arch_reg	ptx_ir.h	/^   bool is_non_arch_reg() const { return m_is_non_arch_reg; }$/;"	f	class:type_info_key
is_non_arch_reg	ptx_ir.h	/^   bool is_non_arch_reg() const$/;"	f	class:symbol
is_param_kernel	ptx_ir.h	/^   bool is_param_kernel() const { return m_space_spec == param_space_kernel;}$/;"	f	class:type_info_key
is_param_local	ptx_ir.h	/^   bool is_param_local() const { return m_is_param_local; }$/;"	f	class:symbol
is_param_local	ptx_ir.h	/^   bool is_param_local() const { return m_space_spec == param_space_local; }$/;"	f	class:type_info_key
is_param_local	ptx_ir.h	/^   bool is_param_local() const$/;"	f	class:operand_info
is_param_unclassified	ptx_ir.h	/^   bool is_param_unclassified() const { return m_space_spec == param_space_unclassified; }$/;"	f	class:type_info_key
is_ptr_shared	ptx_ir.h	/^   bool is_ptr_shared() const { assert(m_valid); return (m_is_ptr and m_ptr_space == shared_space); }$/;"	f	class:param_info
is_reg	ptx_ir.h	/^   bool is_reg() const { return m_is_reg; }$/;"	f	class:arg_buffer_t
is_reg	ptx_ir.h	/^   bool is_reg() const { return m_space_spec == reg_space;} $/;"	f	class:type_info_key
is_reg	ptx_ir.h	/^   bool is_reg() const$/;"	f	class:operand_info
is_reg	ptx_ir.h	/^   bool is_reg() const$/;"	f	class:symbol
is_return_var	ptx_ir.h	/^   bool is_return_var() const { return m_is_return_var; }$/;"	f	class:operand_info
is_shared	ptx_ir.h	/^   bool is_shared() const { return m_is_shared;}$/;"	f	class:symbol
is_shared	ptx_ir.h	/^   bool is_shared() const { return m_space_spec == shared_space;}$/;"	f	class:type_info_key
is_shared	ptx_ir.h	/^   bool is_shared() const {$/;"	f	class:operand_info
is_tex	ptx_ir.h	/^   bool is_tex() const { return m_is_tex;}$/;"	f	class:symbol
is_tex	ptx_ir.h	/^   bool is_tex() const { return m_space_spec == tex_space;}$/;"	f	class:type_info_key
is_tex	ptx_ir.h	/^   bool is_tex() const { return m_value.m_symbolic->is_tex();}$/;"	f	class:operand_info
is_to	ptx_ir.h	/^   bool is_to() const { return m_to_option; }$/;"	f	class:ptx_instruction
is_uni	ptx_ir.h	/^   bool is_uni() const { return m_uni;}$/;"	f	class:ptx_instruction
is_valid	ptx_ir.h	/^   bool is_valid() const { return m_valid; }$/;"	f	class:operand_info
is_vector	ptx_ir.h	/^   bool is_vector() const$/;"	f	class:operand_info
is_wide	ptx_ir.h	/^   bool is_wide() const { return m_wide;}$/;"	f	class:ptx_instruction
isnanf	cuda-math.h	/^int isnanf(float a) $/;"	f
isspace_global	cuda-sim.cc	/^bool isspace_global( addr_t addr )$/;"	f
isspace_local	cuda-sim.cc	/^bool isspace_local( unsigned smid, unsigned hwtid, addr_t addr )$/;"	f
isspace_shared	cuda-sim.cc	/^bool isspace_shared( unsigned smid, addr_t addr )$/;"	f
isspacep_impl	instructions.cc	/^void isspacep_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
iterator	ptx_ir.h	/^   typedef std::list<symbol*>::iterator iterator;$/;"	t	class:symbol_table
keep_intermediate_files	ptx_loader.cc	/^bool keep_intermediate_files() {return g_keep_intermediate_files;}$/;"	f
label_t	ptx_ir.h	/^   unsigned_t, symbolic_t, label_t, v_reg_t, v_float_op_t, v_double_op_t,$/;"	e	enum:operand_type
labels	ptx_ir.h	/^   std::map<std::string,unsigned> labels;$/;"	m	class:function_info
last_callback	ptx_sim.h	/^   dram_callback_t last_callback() const { return m_last_dram_callback;}$/;"	f	class:ptx_thread_info
last_eaddr	ptx_sim.h	/^   addr_t last_eaddr() const { return m_last_effective_address;}$/;"	f	class:ptx_thread_info
last_space	ptx_sim.h	/^   memory_space_t last_space() const { return m_last_memory_space;}$/;"	f	class:ptx_thread_info
last_was_call	ptx_sim.h	/^   bool last_was_call() const { return m_last_was_call; }$/;"	f	class:ptx_thread_info
latency	ptx-stats.cc	/^    unsigned long long latency;$/;"	m	class:ptx_file_line_stats	file:
ld_exec	instructions.cc	/^void ld_exec( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
ld_impl	instructions.cc	/^void ld_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
ldu_impl	instructions.cc	/^void ldu_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
lg2_impl	instructions.cc	/^void lg2_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
line	ptx-stats.cc	/^    unsigned line;$/;"	m	class:ptx_file_line	file:
line	ptxinfo.y	/^line: 	HEADER INFO COLON line_info$/;"	l
line_info	ptxinfo.y	/^line_info: function_name$/;"	l
list_param	cuda-sim.cc	/^void function_info::list_param( FILE *fout ) const$/;"	f	class:function_info
literal_list	ptx.y	/^literal_list: literal_operand$/;"	l
literal_operand	ptx.y	/^literal_operand : INT_OPERAND { add_literal_int($1); }$/;"	l
local_mem_framesize	ptx_ir.h	/^   unsigned local_mem_framesize() const $/;"	f	class:function_info
local_to_generic	cuda-sim.cc	/^addr_t local_to_generic( unsigned smid, unsigned hwtid, addr_t addr )$/;"	f
lookup	ptx_ir.cc	/^symbol *symbol_table::lookup( const char *identifier ) $/;"	f	class:symbol_table
low	ptx_sim.h	/^       unsigned int low;$/;"	m	struct:ptx_reg_t::__anon2
lowest	ptx_sim.h	/^       unsigned int lowest;$/;"	m	struct:ptx_reg_t::__anon2
ls	ptx_sim.h	/^      unsigned ls;$/;"	m	struct:ptx_reg_t::__anon1
m_NPC	ptx_sim.h	/^   unsigned m_NPC;$/;"	m	class:ptx_thread_info
m_PC	ptx_ir.h	/^   addr_t            m_PC;$/;"	m	class:ptx_instruction
m_PC	ptx_sim.h	/^   unsigned       m_PC;$/;"	m	struct:stack_entry
m_PC	ptx_sim.h	/^   unsigned m_PC;$/;"	m	class:ptx_thread_info
m_RPC	ptx_sim.h	/^   unsigned       m_RPC;$/;"	m	struct:stack_entry
m_RPC	ptx_sim.h	/^   unsigned m_RPC;$/;"	m	class:ptx_thread_info
m_RPC_updated	ptx_sim.h	/^   bool m_RPC_updated;$/;"	m	class:ptx_thread_info
m_abs	ptx_ir.h	/^   bool                m_abs;$/;"	m	class:ptx_instruction
m_addr_offset	ptx_ir.h	/^   int m_addr_offset;$/;"	m	class:operand_info
m_addr_space	ptx_ir.h	/^   enum _memory_space_t m_addr_space;$/;"	m	class:operand_info	typeref:enum:operand_info::_memory_space_t
m_address	ptx_ir.h	/^   unsigned m_address;$/;"	m	class:symbol
m_address_valid	ptx_ir.h	/^   bool m_address_valid;$/;"	m	class:symbol
m_alignment_spec	ptx_ir.h	/^   int m_alignment_spec;$/;"	m	class:type_info_key
m_arch_reg_num	ptx_ir.h	/^   unsigned m_arch_reg_num; $/;"	m	class:symbol
m_args	ptx_ir.h	/^   std::vector<const symbol*> m_args;$/;"	m	class:function_info
m_array_dim	ptx_ir.h	/^   int m_array_dim;$/;"	m	class:type_info_key
m_assembled	ptx_ir.h	/^   bool m_assembled;$/;"	m	class:function_info
m_at_barrier	ptx_sim.h	/^   bool m_at_barrier;$/;"	m	class:ptx_thread_info
m_atomic_spec	ptx_ir.h	/^   int m_atomic_spec;$/;"	m	class:ptx_instruction
m_back_edges	ptx_ir.h	/^   std::list<std::pair<unsigned, unsigned> > m_back_edges;$/;"	m	class:function_info
m_barrier_num	ptx_sim.h	/^   int m_barrier_num;$/;"	m	class:ptx_thread_info
m_basic_block	ptx_ir.h	/^   basic_block_t        *m_basic_block;$/;"	m	class:ptx_instruction
m_basic_blocks	ptx_ir.h	/^   std::vector<basic_block_t*> m_basic_blocks;$/;"	m	class:function_info
m_branch_taken	ptx_sim.h	/^   bool        m_branch_taken;$/;"	m	class:ptx_thread_info
m_breakaddrs	ptx_sim.h	/^   std::stack<class operand_info> m_breakaddrs;$/;"	m	class:ptx_thread_info
m_cache_option	ptx_ir.h	/^   unsigned            m_cache_option;$/;"	m	class:ptx_instruction
m_call_uid	ptx_sim.h	/^   unsigned       m_call_uid;$/;"	m	struct:stack_entry
m_callstack	ptx_sim.h	/^   std::list<stack_entry> m_callstack;$/;"	m	class:ptx_thread_info
m_compare_op	ptx_ir.h	/^   unsigned            m_compare_op;$/;"	m	class:ptx_instruction
m_const_mem_offset	ptx_ir.h	/^   addr_t m_const_mem_offset;$/;"	m	class:operand_info
m_const_next	ptx_ir.h	/^   unsigned m_const_next;$/;"	m	class:symbol_table
m_consts	ptx_ir.h	/^   std::list<symbol*> m_consts;$/;"	m	class:symbol_table
m_core	ptx_sim.h	/^   core_t *m_core;$/;"	m	class:ptx_thread_info
m_cta_info	ptx_sim.h	/^   ptx_cta_info   *m_cta_info;$/;"	m	class:ptx_thread_info
m_ctaid	ptx_sim.h	/^   dim3   m_ctaid;$/;"	m	class:ptx_thread_info
m_cycle_done	ptx_sim.h	/^   unsigned m_cycle_done;$/;"	m	class:ptx_thread_info
m_dangling_pointers	ptx_sim.h	/^   std::set<ptx_thread_info*>  m_dangling_pointers;$/;"	m	class:ptx_cta_info
m_data	memory.h	/^   map_t m_data;$/;"	m	class:memory_space_impl
m_data	memory.h	/^   unsigned char *m_data;$/;"	m	class:mem_storage
m_debug_trace_regs_modified	ptx_sim.h	/^   std::list<reg_map_t> m_debug_trace_regs_modified;$/;"	m	class:ptx_thread_info
m_debug_trace_regs_read	ptx_sim.h	/^   std::list<reg_map_t> m_debug_trace_regs_read;$/;"	m	class:ptx_thread_info
m_decl_location	ptx_ir.h	/^   std::string m_decl_location;$/;"	m	class:symbol
m_double	ptx_ir.h	/^      double          m_double;$/;"	m	union:operand_info::__anon3
m_double_operand_type	ptx_ir.h	/^   int m_double_operand_type;$/;"	m	class:operand_info
m_dst	ptx_ir.h	/^   const symbol *m_dst;$/;"	m	class:arg_buffer_t
m_enable_debug_trace	ptx_sim.h	/^   bool m_enable_debug_trace;$/;"	m	class:ptx_thread_info
m_entry_point	ptx_ir.h	/^   bool m_entry_point;$/;"	m	class:function_info
m_exit	ptx_ir.h	/^   bool                m_exit;$/;"	m	class:ptx_instruction
m_extern	ptx_ir.h	/^   bool m_extern;$/;"	m	class:function_info
m_extern_spec	ptx_ir.h	/^   int m_extern_spec;$/;"	m	class:type_info_key
m_float	ptx_ir.h	/^      float           m_float;$/;"	m	union:operand_info::__anon3
m_func_info	ptx_sim.h	/^   function_info *m_func_info;$/;"	m	class:ptx_thread_info
m_func_info	ptx_sim.h	/^   function_info *m_func_info;$/;"	m	struct:stack_entry
m_function	ptx_ir.h	/^   function_info *m_function; \/\/ used for function symbols$/;"	m	class:symbol
m_function_info_lookup	ptx_ir.h	/^   std::map<std::string,function_info*> m_function_info_lookup;$/;"	m	class:symbol_table
m_function_symtab_lookup	ptx_ir.h	/^   std::map<std::string,symbol_table*> m_function_symtab_lookup;$/;"	m	class:symbol_table
m_functionalSimulationMode	ptx_sim.h	/^   bool m_functionalSimulationMode; $/;"	m	class:ptx_thread_info
m_geom_spec	ptx_ir.h	/^   int m_geom_spec;$/;"	m	class:ptx_instruction
m_global_next	ptx_ir.h	/^   unsigned m_global_next;$/;"	m	class:symbol_table
m_globals	ptx_ir.h	/^   std::list<symbol*> m_globals;$/;"	m	class:symbol_table
m_gpu	ptx_sim.h	/^   gpgpu_t *m_gpu;$/;"	m	class:ptx_thread_info
m_gridid	ptx_sim.h	/^   unsigned m_gridid;$/;"	m	class:ptx_thread_info
m_hi	ptx_ir.h	/^   bool                m_hi;$/;"	m	class:ptx_instruction
m_hw_ctaid	ptx_sim.h	/^   unsigned m_hw_ctaid;$/;"	m	class:ptx_thread_info
m_hw_sid	ptx_sim.h	/^   unsigned m_hw_sid;$/;"	m	class:ptx_thread_info
m_hw_tid	ptx_sim.h	/^   unsigned m_hw_tid;$/;"	m	class:ptx_thread_info
m_hw_wid	ptx_sim.h	/^   unsigned m_hw_wid;$/;"	m	class:ptx_thread_info
m_icount	ptx_sim.h	/^   unsigned m_icount;$/;"	m	class:ptx_thread_info
m_immediate_address	ptx_ir.h	/^   bool m_immediate_address;$/;"	m	class:operand_info
m_init	ptx_ir.h	/^   bool m_init;$/;"	m	class:type_info_key
m_initializer	ptx_ir.h	/^   std::list<operand_info> m_initializer;$/;"	m	class:symbol
m_inst_size	ptx_ir.h	/^   unsigned m_inst_size; \/\/ bytes$/;"	m	class:ptx_instruction
m_instr_mem	ptx_ir.h	/^   ptx_instruction **m_instr_mem;$/;"	m	class:function_info
m_instr_mem_index	ptx_ir.h	/^   int m_instr_mem_index; \/\/index into m_instr_mem array$/;"	m	class:ptx_instruction
m_instr_mem_size	ptx_ir.h	/^   unsigned m_instr_mem_size;$/;"	m	class:function_info
m_instructions	ptx_ir.h	/^   std::list<ptx_instruction*> m_instructions;$/;"	m	class:function_info
m_int	ptx_ir.h	/^      int             m_int;$/;"	m	union:operand_info::__anon3
m_is_const	ptx_ir.h	/^   bool m_is_const;$/;"	m	class:symbol
m_is_func_addr	ptx_ir.h	/^   bool m_is_func_addr;$/;"	m	class:symbol
m_is_function	ptx_ir.h	/^   int m_is_function;$/;"	m	class:type_info_key
m_is_global	ptx_ir.h	/^   bool m_is_global;$/;"	m	class:symbol
m_is_label	ptx_ir.h	/^   bool m_is_label;$/;"	m	class:symbol
m_is_local	ptx_ir.h	/^   bool m_is_local;$/;"	m	class:symbol
m_is_non_arch_reg	ptx_ir.h	/^   bool m_is_non_arch_reg;$/;"	m	class:operand_info
m_is_non_arch_reg	ptx_ir.h	/^   bool m_is_non_arch_reg;$/;"	m	class:type_info_key
m_is_param	ptx_ir.h	/^   bool m_is_param;$/;"	m	class:arg_buffer_t
m_is_param_local	ptx_ir.h	/^   bool m_is_param_local;$/;"	m	class:symbol
m_is_ptr	ptx_ir.h	/^   bool m_is_ptr; $/;"	m	class:param_info
m_is_reg	ptx_ir.h	/^   bool m_is_reg;$/;"	m	class:arg_buffer_t
m_is_return_var	ptx_ir.h	/^   bool m_is_return_var;$/;"	m	class:operand_info
m_is_shared	ptx_ir.h	/^   bool m_is_shared;$/;"	m	class:symbol
m_is_tex	ptx_ir.h	/^   bool m_is_tex;$/;"	m	class:symbol
m_kernel	ptx_sim.h	/^   kernel_info_t &m_kernel;$/;"	m	class:ptx_thread_info
m_kernel_info	ptx_ir.h	/^   struct gpgpu_ptx_sim_kernel_info m_kernel_info;$/;"	m	class:function_info	typeref:struct:function_info::gpgpu_ptx_sim_kernel_info
m_kernel_params	ptx_ir.h	/^   std::map<std::string,param_t> m_kernel_params;$/;"	m	class:function_info
m_label	ptx_ir.h	/^   const symbol           *m_label;$/;"	m	class:ptx_instruction
m_last_dram_callback	ptx_sim.h	/^   dram_callback_t   m_last_dram_callback; $/;"	m	class:ptx_thread_info
m_last_effective_address	ptx_sim.h	/^   addr_t         m_last_effective_address;$/;"	m	class:ptx_thread_info
m_last_memory_space	ptx_sim.h	/^   memory_space_t m_last_memory_space;$/;"	m	class:ptx_thread_info
m_last_set_operand_value	ptx_sim.h	/^   ptx_reg_t m_last_set_operand_value;$/;"	m	class:ptx_thread_info
m_last_was_call	ptx_sim.h	/^   bool m_last_was_call;$/;"	m	class:ptx_thread_info
m_liveThreadCount	cuda-sim.h	/^    unsigned * m_liveThreadCount;$/;"	m	class:functionalCoreSim
m_lo	ptx_ir.h	/^   bool                m_lo;$/;"	m	class:ptx_instruction
m_local_mem	ptx_sim.h	/^   memory_space   *m_local_mem;$/;"	m	class:ptx_thread_info
m_local_mem_framesize	ptx_ir.h	/^   unsigned m_local_mem_framesize;$/;"	m	class:function_info
m_local_mem_stack_pointer	ptx_sim.h	/^   unsigned m_local_mem_stack_pointer;$/;"	m	class:ptx_thread_info
m_local_next	ptx_ir.h	/^   unsigned m_local_next;$/;"	m	class:symbol_table
m_log2_block_size	memory.h	/^   unsigned m_log2_block_size;$/;"	m	class:memory_space_impl
m_map_f64_to_f32	ptx_sim.h	/^      bool     m_map_f64_to_f32; $/;"	m	class:ptx_version
m_membar_level	ptx_ir.h	/^   int m_membar_level;$/;"	m	class:ptx_instruction
m_name	memory.h	/^   std::string m_name;$/;"	m	class:memory_space_impl
m_name	ptx_ir.h	/^   std::string m_name;$/;"	m	class:function_info
m_name	ptx_ir.h	/^   std::string m_name;$/;"	m	class:param_info
m_name	ptx_ir.h	/^   std::string m_name;$/;"	m	class:symbol
m_nbytes	memory.h	/^   unsigned m_nbytes;$/;"	m	class:mem_storage
m_nctaid	ptx_sim.h	/^   dim3   m_nctaid;$/;"	m	class:ptx_thread_info
m_neg	ptx_ir.h	/^   bool                m_neg;$/;"	m	class:ptx_instruction
m_neg_pred	ptx_ir.h	/^   bool                    m_neg_pred;$/;"	m	class:ptx_instruction
m_neg_pred	ptx_ir.h	/^   bool m_neg_pred;$/;"	m	class:operand_info
m_ntid	ptx_sim.h	/^   dim3   m_ntid;$/;"	m	class:ptx_thread_info
m_offset	ptx_ir.h	/^   unsigned m_offset;$/;"	m	class:param_info
m_opcode	ptx_ir.h	/^   int                     m_opcode;$/;"	m	class:ptx_instruction
m_operand_lohi	ptx_ir.h	/^   int m_operand_lohi;$/;"	m	class:operand_info
m_operand_neg	ptx_ir.h	/^   bool m_operand_neg;$/;"	m	class:operand_info
m_operands	ptx_ir.h	/^   std::vector<operand_info> m_operands;$/;"	m	class:ptx_instruction
m_options	ptx_ir.h	/^   std::list<int>          m_options;$/;"	m	class:ptx_instruction
m_param_bytes	ptx_ir.h	/^   unsigned  m_param_bytes;$/;"	m	class:arg_buffer_t
m_param_value	ptx_ir.h	/^   void     *m_param_value;$/;"	m	class:arg_buffer_t
m_parent	ptx_ir.h	/^   symbol_table *m_parent;$/;"	m	class:symbol_table
m_pred	ptx_ir.h	/^   const symbol           *m_pred;$/;"	m	class:ptx_instruction
m_pred_mod	ptx_ir.h	/^   int                    m_pred_mod;$/;"	m	class:ptx_instruction
m_ptr_space	ptx_ir.h	/^   memory_space_t m_ptr_space; $/;"	m	class:param_info
m_ptx_extensions	ptx_sim.h	/^      unsigned m_ptx_extensions;$/;"	m	class:ptx_version
m_ptx_kernel_param_info	ptx_ir.h	/^   std::map<unsigned,param_info> m_ptx_kernel_param_info;$/;"	m	class:function_info
m_ptx_save_converted_ptxplus	ptx_loader.cc	/^bool m_ptx_save_converted_ptxplus;$/;"	v
m_ptx_version	ptx_ir.h	/^   ptx_version m_ptx_version;$/;"	m	class:symbol_table
m_ptx_version	ptx_sim.h	/^      float    m_ptx_version;$/;"	m	class:ptx_version
m_reg_allocator	ptx_ir.h	/^   unsigned m_reg_allocator;$/;"	m	class:symbol_table
m_reg_num	ptx_ir.h	/^   unsigned m_reg_num; $/;"	m	class:symbol
m_reg_num_valid	ptx_ir.h	/^   bool m_reg_num_valid; $/;"	m	class:symbol
m_reg_value	ptx_ir.h	/^   ptx_reg_t m_reg_value;$/;"	m	class:arg_buffer_t
m_regs	ptx_sim.h	/^   std::list<reg_map_t> m_regs;$/;"	m	class:ptx_thread_info
m_return_var	ptx_ir.h	/^   operand_info m_return_var;$/;"	m	class:ptx_instruction
m_return_var_dst	ptx_sim.h	/^   const symbol  *m_return_var_dst;$/;"	m	struct:stack_entry
m_return_var_src	ptx_sim.h	/^   const symbol  *m_return_var_src;$/;"	m	struct:stack_entry
m_return_var_sym	ptx_ir.h	/^   const symbol *m_return_var_sym;$/;"	m	class:function_info
m_rounding_mode	ptx_ir.h	/^   unsigned            m_rounding_mode;$/;"	m	class:ptx_instruction
m_saturation_mode	ptx_ir.h	/^   unsigned            m_saturation_mode;$/;"	m	class:ptx_instruction
m_scalar_type	ptx_ir.h	/^   std::list<int>          m_scalar_type;$/;"	m	class:ptx_instruction
m_scalar_type_spec	ptx_ir.h	/^   int m_scalar_type_spec;$/;"	m	class:type_info_key
m_scope	ptx_ir.h	/^   symbol_table *m_scope;$/;"	m	class:type_info
m_scope_name	ptx_ir.h	/^   std::string m_scope_name;$/;"	m	class:symbol_table
m_shared_mem	ptx_sim.h	/^   memory_space   *m_shared_mem;$/;"	m	class:ptx_thread_info
m_shared_next	ptx_ir.h	/^   unsigned m_shared_next;$/;"	m	class:symbol_table
m_size	ptx_ir.h	/^   size_t m_size;$/;"	m	class:param_info
m_size	ptx_ir.h	/^   unsigned m_size; \/\/ in bytes$/;"	m	class:symbol
m_sm_idx	ptx_sim.h	/^   unsigned                m_sm_idx;$/;"	m	class:ptx_cta_info
m_sm_version	ptx_sim.h	/^      unsigned m_sm_version;$/;"	m	class:ptx_version
m_sm_version_str	ptx_sim.h	/^      std::string m_sm_version_str;$/;"	m	class:ptx_version
m_sm_version_valid	ptx_sim.h	/^      unsigned m_sm_version_valid;$/;"	m	class:ptx_version
m_source	ptx_ir.h	/^   std::string          m_source;$/;"	m	class:ptx_instruction
m_source_file	ptx_ir.h	/^   std::string             m_source_file;$/;"	m	class:ptx_instruction
m_source_line	ptx_ir.h	/^   unsigned                m_source_line;$/;"	m	class:ptx_instruction
m_space_spec	ptx_ir.h	/^   memory_space_t m_space_spec; $/;"	m	class:type_info_key
m_space_spec	ptx_ir.h	/^   memory_space_t m_space_spec;$/;"	m	class:ptx_instruction
m_src_op	ptx_ir.h	/^   operand_info m_src_op;$/;"	m	class:arg_buffer_t
m_start_PC	ptx_ir.h	/^   unsigned m_start_PC;$/;"	m	class:function_info
m_symbol_table	ptx_sim.h	/^   symbol_table  *m_symbol_table;$/;"	m	class:ptx_thread_info
m_symbol_table	ptx_sim.h	/^   symbol_table  *m_symbol_table;$/;"	m	struct:stack_entry
m_symbolic	ptx_ir.h	/^      const symbol*  m_symbolic;$/;"	m	union:operand_info::__anon3
m_symbols	ptx_ir.h	/^   std::map<std::string, symbol *> m_symbols; \/\/map from name of register to pointers to the registers$/;"	m	class:symbol_table
m_symtab	ptx_ir.h	/^   symbol_table *m_symtab;$/;"	m	class:function_info
m_tex_next	ptx_ir.h	/^   unsigned m_tex_next;$/;"	m	class:symbol_table
m_texmode_unified	ptx_sim.h	/^      bool     m_texmode_unified;$/;"	m	class:ptx_version
m_thread_done	ptx_sim.h	/^   bool m_thread_done;$/;"	m	class:ptx_thread_info
m_threads_in_cta	ptx_sim.h	/^   std::set<ptx_thread_info*>    m_threads_in_cta;$/;"	m	class:ptx_cta_info
m_threads_that_have_exited	ptx_sim.h	/^   std::set<ptx_thread_info*>  m_threads_that_have_exited;$/;"	m	class:ptx_cta_info
m_tid	ptx_sim.h	/^   dim3   m_tid;$/;"	m	class:ptx_thread_info
m_to_option	ptx_ir.h	/^   bool                m_to_option;$/;"	m	class:ptx_instruction
m_type	ptx_ir.h	/^   const type_info *m_type;$/;"	m	class:symbol
m_type	ptx_ir.h	/^   enum operand_type m_type;$/;"	m	class:operand_info	typeref:enum:operand_info::operand_type
m_type	ptx_ir.h	/^   int m_type;$/;"	m	class:param_info
m_type_info	ptx_ir.h	/^   type_info_key m_type_info;$/;"	m	class:type_info
m_types	ptx_ir.h	/^   std::map<type_info_key,type_info*,type_info_key_compare>  m_types;$/;"	m	class:symbol_table
m_uid	ptx_ir.h	/^   unsigned          m_uid;$/;"	m	class:ptx_instruction
m_uid	ptx_ir.h	/^   unsigned m_uid;$/;"	m	class:function_info
m_uid	ptx_ir.h	/^   unsigned m_uid;$/;"	m	class:operand_info
m_uid	ptx_ir.h	/^   unsigned m_uid;$/;"	m	class:symbol
m_uid	ptx_sim.h	/^   unsigned long long         m_uid;$/;"	m	class:ptx_cta_info
m_uid	ptx_sim.h	/^   unsigned m_uid;$/;"	m	class:ptx_thread_info
m_uni	ptx_ir.h	/^   bool                m_uni; \/\/if branch instruction, this evaluates to true for uniform branches (ie jumps)$/;"	m	class:ptx_instruction
m_unsigned	ptx_ir.h	/^      unsigned int    m_unsigned;$/;"	m	union:operand_info::__anon3
m_valid	ptx_ir.h	/^   bool m_valid;$/;"	m	class:operand_info
m_valid	ptx_ir.h	/^   bool m_valid;$/;"	m	class:param_info
m_valid	ptx_sim.h	/^      bool     m_valid;$/;"	m	class:ptx_version
m_valid	ptx_sim.h	/^   bool   m_valid;$/;"	m	class:ptx_thread_info
m_valid	ptx_sim.h	/^   bool m_valid;$/;"	m	struct:stack_entry
m_value	ptx_ir.h	/^   param_t m_value;$/;"	m	class:param_info
m_value	ptx_ir.h	/^   } m_value;$/;"	m	class:operand_info	typeref:union:operand_info::__anon3
m_value_set	ptx_ir.h	/^   bool m_value_set;$/;"	m	class:param_info
m_vdouble	ptx_ir.h	/^      double          m_vdouble[4];$/;"	m	union:operand_info::__anon3
m_vector	ptx_ir.h	/^   bool m_vector;$/;"	m	class:operand_info
m_vector_spec	ptx_ir.h	/^   int m_vector_spec;$/;"	m	class:ptx_instruction
m_vector_spec	ptx_ir.h	/^   int m_vector_spec;$/;"	m	class:type_info_key
m_vector_symbolic	ptx_ir.h	/^      const symbol**  m_vector_symbolic;$/;"	m	union:operand_info::__anon3
m_vfloat	ptx_ir.h	/^      float           m_vfloat[4];$/;"	m	union:operand_info::__anon3
m_vint	ptx_ir.h	/^      int             m_vint[4];$/;"	m	union:operand_info::__anon3
m_vote_mode	ptx_ir.h	/^   enum vote_mode_t m_vote_mode;$/;"	m	class:ptx_instruction	typeref:enum:ptx_instruction::vote_mode_t
m_vunsigned	ptx_ir.h	/^      unsigned int    m_vunsigned[4];$/;"	m	union:operand_info::__anon3
m_warpAtBarrier	cuda-sim.h	/^    bool* m_warpAtBarrier;$/;"	m	class:functionalCoreSim
m_watchpoints	memory.h	/^   std::map<unsigned,mem_addr_t> m_watchpoints;$/;"	m	class:memory_space_impl
m_wide	ptx_ir.h	/^   bool                m_wide;$/;"	m	class:ptx_instruction
mad24_impl	instructions.cc	/^void mad24_impl( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f
mad_def	instructions.cc	/^void mad_def( const ptx_instruction *pI, ptx_thread_info *thread, bool use_carry ) $/;"	f
mad_impl	instructions.cc	/^void mad_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
madp_impl	instructions.cc	/^void madp_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
main	memory.cc	/^int main(int argc, char *argv[] )$/;"	f
make_copy	ptx_ir.h	/^   void make_copy( const arg_buffer_t &another )$/;"	f	class:arg_buffer_t
make_memory_operand	ptx_ir.h	/^   void make_memory_operand() { m_type = memory_t;}$/;"	f	class:operand_info
map_t	memory.h	/^   typedef mem_map<mem_addr_t,mem_storage<BSIZE> > map_t;$/;"	t	class:memory_space_impl
mask_and	ptx_sim.h	/^   void mask_and( unsigned ms, unsigned ls )$/;"	f	union:ptx_reg_t
mask_or	ptx_sim.h	/^   void mask_or( unsigned ms, unsigned ls )$/;"	f	union:ptx_reg_t
max	cuda-math.h	71;"	d
max_impl	instructions.cc	/^void max_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
mem_addr_t	memory.h	/^typedef address_type mem_addr_t;$/;"	t
mem_map	memory.h	34;"	d
mem_storage	memory.h	/^   mem_storage( const mem_storage &another )$/;"	f	class:mem_storage
mem_storage	memory.h	/^   mem_storage()$/;"	f	class:mem_storage
mem_storage	memory.h	/^template<unsigned BSIZE> class mem_storage {$/;"	c
membar_impl	instructions.cc	/^void membar_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
membar_level	ptx_ir.h	/^   int membar_level() const { return m_membar_level; }$/;"	f	class:ptx_instruction
memcpy_from_gpu	cuda-sim.cc	/^void gpgpu_t::memcpy_from_gpu( void *dst, size_t src_start_addr, size_t count )$/;"	f	class:gpgpu_t
memcpy_gpu_to_gpu	cuda-sim.cc	/^void gpgpu_t::memcpy_gpu_to_gpu( size_t dst, size_t src, size_t count )$/;"	f	class:gpgpu_t
memcpy_to_gpu	cuda-sim.cc	/^void gpgpu_t::memcpy_to_gpu( size_t dst_start_addr, const void *src, size_t count )$/;"	f	class:gpgpu_t
memory_h_INCLUDED	memory.h	29;"	d
memory_operand	ptx.y	/^memory_operand : LEFT_SQUARE_BRACKET address_expression RIGHT_SQUARE_BRACKET { add_memory_operand(); }$/;"	l
memory_space	memory.h	/^class memory_space$/;"	c
memory_space_impl	memory.cc	/^template<unsigned BSIZE> memory_space_impl<BSIZE>::memory_space_impl( std::string name, unsigned hash_size )$/;"	f	class:memory_space_impl
memory_space_impl	memory.h	/^template<unsigned BSIZE> class memory_space_impl : public memory_space {$/;"	c
memory_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
min	cuda-math.h	72;"	d
min_impl	instructions.cc	/^void min_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
mov_impl	instructions.cc	/^void mov_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
ms	ptx_sim.h	/^      unsigned ms;$/;"	m	struct:ptx_reg_t::__anon1
mul24_impl	instructions.cc	/^void mul24_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
mul_impl	instructions.cc	/^void mul_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
my_abs	instructions.cc	636;"	d	file:
my_cuda_printf	cuda_device_printf.cc	/^void my_cuda_printf(const char *fmtstr,const char *arg_list)$/;"	f
mymax	ptx_parser.cc	196;"	d	file:
name	ptx_ir.h	/^   const std::string &name() const { return m_name;}$/;"	f	class:symbol
name	ptx_ir.h	/^   const std::string &name() const$/;"	f	class:operand_info
nandn_impl	instructions.cc	/^void nandn_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
neg_impl	instructions.cc	/^void neg_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
next_instr	ptx_sim.h	/^   unsigned next_instr()$/;"	f	class:ptx_thread_info
next_reg_num	ptx_ir.h	/^   unsigned next_reg_num() { return ++m_reg_allocator;}$/;"	f	class:symbol_table
nop_impl	instructions.cc	/^void nop_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
norn_impl	instructions.cc	/^void norn_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
not_impl	instructions.cc	/^void not_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
num_args	ptx_ir.h	/^   unsigned num_args() const$/;"	f	class:function_info
num_reconvergence_pairs	ptx_ir.h	/^   unsigned num_reconvergence_pairs;$/;"	m	class:function_info
num_threads	ptx_sim.cc	/^unsigned ptx_cta_info::num_threads() const$/;"	f	class:ptx_cta_info
offset	ptx_sim.h	/^   size_t offset;$/;"	m	struct:param_t
op_iter_begin	ptx_ir.h	/^   const_iterator op_iter_begin() const $/;"	f	class:ptx_instruction
op_iter_end	ptx_ir.h	/^   const_iterator op_iter_end() const $/;"	f	class:ptx_instruction
opcode_initiation_dp	cuda-sim.cc	/^char *opcode_initiation_int, *opcode_initiation_fp, *opcode_initiation_dp;$/;"	v
opcode_initiation_fp	cuda-sim.cc	/^char *opcode_initiation_int, *opcode_initiation_fp, *opcode_initiation_dp;$/;"	v
opcode_initiation_int	cuda-sim.cc	/^char *opcode_initiation_int, *opcode_initiation_fp, *opcode_initiation_dp;$/;"	v
opcode_latency_dp	cuda-sim.cc	/^char *opcode_latency_int, *opcode_latency_fp, *opcode_latency_dp;$/;"	v
opcode_latency_fp	cuda-sim.cc	/^char *opcode_latency_int, *opcode_latency_fp, *opcode_latency_dp;$/;"	v
opcode_latency_int	cuda-sim.cc	/^char *opcode_latency_int, *opcode_latency_fp, *opcode_latency_dp;$/;"	v
opcode_spec	ptx.y	/^opcode_spec: OPCODE { add_opcode($1); } option_list$/;"	l
opcode_t	opcodes.h	/^enum opcode_t {$/;"	g
opcodes_h_included	opcodes.h	29;"	d
operand	ptx.y	/^operand: IDENTIFIER  { add_scalar_operand( $1 ); }$/;"	l
operand_info	ptx_ir.h	/^   operand_info( const symbol *addr )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( const symbol *addr, int offset )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( const symbol *addr1, const symbol *addr2 )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( const symbol *s1, const symbol *s2, const symbol *s3, const symbol *s4 )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( double x )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( float x )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( int builtin_id, int dim_mod )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( int x )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info( unsigned x )$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^   operand_info()$/;"	f	class:operand_info
operand_info	ptx_ir.h	/^class operand_info {$/;"	c
operand_list	ptx.y	/^operand_list: operand$/;"	l
operand_lookup	ptx_ir.h	/^   const operand_info &operand_lookup( unsigned n ) const$/;"	f	class:ptx_instruction
operand_type	ptx_ir.h	/^enum operand_type {$/;"	g
operator ()	ptx-stats.cc	/^    std::size_t operator()(const ptx_file_line & pfline) const {$/;"	f	struct:hash_ptx_file_line
operator ()	ptx_ir.h	/^   bool operator()( const type_info_key &a, const type_info_key &b ) const$/;"	f	struct:type_info_key_compare
operator <	ptx-stats.cc	/^    bool operator<(const ptx_file_line &other) const {$/;"	f	class:ptx_file_line
operator =	ptx_ir.h	/^   void operator=( const arg_buffer_t &another )$/;"	f	class:arg_buffer_t
operator ==	ptx-stats.cc	/^    bool operator==(const ptx_file_line &other) const {$/;"	f	class:ptx_file_line
operator unsigned char	ptx_sim.h	/^   operator unsigned char() { return u8;}$/;"	f	union:ptx_reg_t
operator unsigned int	ptx_sim.h	/^   operator unsigned int() { return u32;}$/;"	f	union:ptx_reg_t
operator unsigned long long	ptx_sim.h	/^   operator unsigned long long() { return u64;}$/;"	f	union:ptx_reg_t
operator unsigned short	ptx_sim.h	/^   operator unsigned short() { return u16;}$/;"	f	union:ptx_reg_t
option	ptx.y	/^option: type_spec$/;"	l
option_list	ptx.y	/^option_list: option$/;"	l
or_impl	instructions.cc	/^void or_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
orn_impl	instructions.cc	/^void orn_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
pad_address	ptx_parser.cc	/^int pad_address (new_addr_type address, unsigned size, unsigned maxalign) {$/;"	f
param_entry	ptx.y	/^param_entry: PARAM_DIRECTIVE { add_space_spec(param_space_unclassified,0); } variable_spec ptr_spec identifier_spec { add_function_arg(); }$/;"	l
param_info	ptx_ir.h	/^   param_info( std::string name, int type, size_t size, bool is_ptr, memory_space_t ptr_space ) $/;"	f	class:param_info
param_info	ptx_ir.h	/^   param_info() { m_valid = false; m_value_set=false; m_size = 0; m_is_ptr = false; }$/;"	f	class:param_info
param_info	ptx_ir.h	/^class param_info {$/;"	c
param_list	ptx.y	/^param_list: \/*empty*\/$/;"	l
param_t	ptx_sim.h	/^struct param_t {$/;"	s
param_to_shared	cuda-sim.cc	/^void function_info::param_to_shared( memory_space *shared_mem, symbol_table *symtab ) $/;"	f	class:function_info
parse_assert	ptx_parser.cc	214;"	d	file:
parse_assert_impl	ptx_parser.cc	/^void parse_assert_impl( int test_value, const char *file, unsigned line, const char *msg, ... )$/;"	f
parse_error	ptx_parser.cc	213;"	d	file:
parse_error_impl	ptx_parser.cc	/^void parse_error_impl( const char *file, unsigned line, const char *msg, ... )$/;"	f
pc_to_instruction	ptx_ir.h	/^   static const ptx_instruction* pc_to_instruction(unsigned pc) $/;"	f	class:function_info
pdata	ptx_sim.h	/^   const void *pdata;$/;"	m	struct:param_t
pdom	ptx_ir.h	/^   bool pdom(const basic_block_t *B) {$/;"	f	struct:basic_block_t
pmevent_impl	instructions.cc	/^void pmevent_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
pop_breakaddr	ptx_sim.cc	/^const operand_info& ptx_thread_info::pop_breakaddr() $/;"	f	class:ptx_thread_info
popc_impl	instructions.cc	/^void popc_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
postdominator_ids	ptx_ir.h	/^   std::set<int> postdominator_ids;$/;"	m	struct:basic_block_t
pre_decode	cuda-sim.cc	/^void ptx_instruction::pre_decode()$/;"	f	class:ptx_instruction
pred_lookup	decuda_pred_table/decuda_pred_table.cc	/^bool pred_lookup(int condition, int flags)$/;"	f
pred_spec	ptx.y	/^pred_spec: PRED IDENTIFIER  { add_pred($2,0, -1); }$/;"	l
predecessor_ids	ptx_ir.h	/^   std::set<int> predecessor_ids; \/\/indices of other basic blocks in m_basic_blocks array$/;"	m	struct:basic_block_t
prefetch_impl	instructions.cc	/^void prefetch_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
prefetchu_impl	instructions.cc	/^void prefetchu_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
print	memory.cc	/^template<unsigned BSIZE> void memory_space_impl<BSIZE>::print( const char *format, FILE *fout ) const$/;"	f	class:memory_space_impl
print	memory.h	/^   void print( const char *format, FILE *fout ) const$/;"	f	class:mem_storage
print_basic_block_dot	ptx_ir.cc	/^void function_info::print_basic_block_dot()$/;"	f	class:function_info
print_basic_block_links	ptx_ir.cc	/^void function_info::print_basic_block_links()$/;"	f	class:function_info
print_basic_blocks	ptx_ir.cc	/^void function_info::print_basic_blocks()$/;"	f	class:function_info
print_dominators	ptx_ir.cc	/^void function_info::print_dominators()$/;"	f	class:function_info
print_idominators	ptx_ir.cc	/^void function_info::print_idominators()$/;"	f	class:function_info
print_info	ptx_ir.cc	/^void symbol::print_info(FILE *fp) const$/;"	f	class:symbol
print_insn	ptx_ir.cc	/^unsigned function_info::print_insn( unsigned pc, FILE * fp ) const$/;"	f	class:function_info
print_insn	ptx_ir.cc	/^void ptx_instruction::print_insn( FILE *fp ) const$/;"	f	class:ptx_instruction
print_insn	ptx_ir.cc	/^void ptx_instruction::print_insn() const$/;"	f	class:ptx_instruction
print_insn	ptx_sim.cc	/^void ptx_thread_info::print_insn( unsigned pc, FILE * fp ) const$/;"	f	class:ptx_thread_info
print_ipostdominators	ptx_ir.cc	/^void function_info::print_ipostdominators()$/;"	f	class:function_info
print_postdominators	ptx_ir.cc	/^void function_info::print_postdominators()$/;"	f	class:function_info
print_ptx_file	ptx_loader.cc	/^void print_ptx_file( const char *p, unsigned source_num, const char *filename )$/;"	f
print_ptxinfo	cuda-sim.cc	/^void print_ptxinfo()$/;"	f
print_reg	ptx_sim.cc	/^static void print_reg( FILE *fp, std::string name, ptx_reg_t value, symbol_table *symtab )$/;"	f	file:
print_reg	ptx_sim.cc	/^static void print_reg( std::string name, ptx_reg_t value, symbol_table *symtab )$/;"	f	file:
print_set	ptx_ir.cc	/^void print_set(const std::set<int> &A)$/;"	f
print_splash	cuda-sim.cc	/^void print_splash()$/;"	f
prmt_impl	instructions.cc	/^void prmt_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
ptr_align_spec	ptx.y	/^ptr_align_spec: ALIGN_DIRECTIVE INT_OPERAND$/;"	l
ptr_space_spec	ptx.y	/^ptr_space_spec: GLOBAL_DIRECTIVE { add_ptr_spec(global_space); }$/;"	l
ptr_spec	ptx.y	/^ptr_spec: \/*empty*\/$/;"	l
ptx_assemble	cuda-sim.cc	/^void function_info::ptx_assemble()$/;"	f	class:function_info
ptx_begin	ptx_ir.h	/^   ptx_instruction* ptx_begin;$/;"	m	struct:basic_block_t
ptx_cta_info	ptx_sim.cc	/^ptx_cta_info::ptx_cta_info( unsigned sm_idx )$/;"	f	class:ptx_cta_info
ptx_cta_info	ptx_sim.h	/^class ptx_cta_info {$/;"	c
ptx_debug_exec_dump_cond	cuda-sim.cc	/^bool ptx_debug_exec_dump_cond(int thd_uid, addr_t pc)$/;"	f
ptx_end	ptx_ir.h	/^   ptx_instruction* ptx_end;$/;"	m	struct:basic_block_t
ptx_exec_inst	cuda-sim.cc	/^void ptx_thread_info::ptx_exec_inst( warp_inst_t &inst, unsigned lane_id)$/;"	f	class:ptx_thread_info
ptx_fetch_inst	cuda-sim.cc	/^const warp_inst_t *ptx_fetch_inst( address_type pc )$/;"	f
ptx_fetch_inst	cuda-sim.cc	/^void ptx_thread_info::ptx_fetch_inst( inst_t &inst ) const$/;"	f	class:ptx_thread_info
ptx_file_line	ptx-stats.cc	/^    ptx_file_line(const char* s, int l) {$/;"	f	class:ptx_file_line
ptx_file_line	ptx-stats.cc	/^class ptx_file_line $/;"	c	file:
ptx_file_line_stats	ptx-stats.cc	/^    ptx_file_line_stats() $/;"	f	class:ptx_file_line_stats
ptx_file_line_stats	ptx-stats.cc	/^class ptx_file_line_stats$/;"	c	file:
ptx_file_line_stats_add_dram_traffic	ptx-stats.cc	/^void ptx_file_line_stats_add_dram_traffic(unsigned pc, unsigned dram_traffic)$/;"	f
ptx_file_line_stats_add_exec_count	ptx-stats.cc	/^void ptx_file_line_stats_add_exec_count(const ptx_instruction *pInsn)$/;"	f
ptx_file_line_stats_add_inflight_memory_insn	ptx-stats.cc	/^void ptx_file_line_stats_add_inflight_memory_insn(int sc_id, unsigned pc)$/;"	f
ptx_file_line_stats_add_latency	ptx-stats.cc	/^void ptx_file_line_stats_add_latency(unsigned pc, unsigned latency)$/;"	f
ptx_file_line_stats_add_smem_bank_conflict	ptx-stats.cc	/^void ptx_file_line_stats_add_smem_bank_conflict(unsigned pc, unsigned n_way_bkconflict)$/;"	f
ptx_file_line_stats_add_uncoalesced_gmem	ptx-stats.cc	/^void ptx_file_line_stats_add_uncoalesced_gmem(unsigned pc, unsigned n_access)$/;"	f
ptx_file_line_stats_add_warp_divergence	ptx-stats.cc	/^void ptx_file_line_stats_add_warp_divergence(unsigned pc, unsigned n_way_divergence)$/;"	f
ptx_file_line_stats_commit_exposed_latency	ptx-stats.cc	/^void ptx_file_line_stats_commit_exposed_latency(int sc_id, int exposed_latency)$/;"	f
ptx_file_line_stats_create_exposed_latency_tracker	ptx-stats.cc	/^void ptx_file_line_stats_create_exposed_latency_tracker(int n_shader_cores)$/;"	f
ptx_file_line_stats_map_t	ptx-stats.cc	/^typedef tr1_hash_map<ptx_file_line, ptx_file_line_stats, hash_ptx_file_line> ptx_file_line_stats_map_t;$/;"	t	file:
ptx_file_line_stats_map_t	ptx-stats.cc	/^typedef tr1_hash_map<ptx_file_line, ptx_file_line_stats> ptx_file_line_stats_map_t;$/;"	t	file:
ptx_file_line_stats_options	ptx-stats.cc	/^void ptx_file_line_stats_options(option_parser_t opp)$/;"	f
ptx_file_line_stats_sub_inflight_memory_insn	ptx-stats.cc	/^void ptx_file_line_stats_sub_inflight_memory_insn(int sc_id, unsigned pc)$/;"	f
ptx_file_line_stats_tracker	ptx-stats.cc	/^static ptx_file_line_stats_map_t ptx_file_line_stats_tracker;$/;"	v	file:
ptx_file_line_stats_write_file	ptx-stats.cc	/^void ptx_file_line_stats_write_file()$/;"	f
ptx_get_insn_str	cuda-sim.cc	/^std::string ptx_get_insn_str( address_type pc )$/;"	f
ptx_inflight_memory_insn_tracker	ptx-stats.cc	/^class ptx_inflight_memory_insn_tracker$/;"	c	file:
ptx_inflight_memory_insns	ptx-stats.cc	/^    insn_count_map ptx_inflight_memory_insns;$/;"	m	class:ptx_inflight_memory_insn_tracker	file:
ptx_instruction	ptx_ir.cc	/^ptx_instruction::ptx_instruction( int opcode, $/;"	f	class:ptx_instruction
ptx_instruction	ptx_ir.h	/^class ptx_instruction : public warp_inst_t {$/;"	c
ptx_instruction_lookup	ptx_parser.cc	/^const ptx_instruction *ptx_instruction_lookup( const char *filename, unsigned linenumber )$/;"	f
ptx_ir_INCLUDED	ptx_ir.h	29;"	d
ptx_kernel_nregs	ptx_ir.cc	/^unsigned ptx_kernel_nregs( void *kernel_impl )$/;"	f
ptx_kernel_shmem_size	ptx_ir.cc	/^unsigned ptx_kernel_shmem_size( void *kernel_impl )$/;"	f
ptx_line_stats_filename	ptx-stats.cc	/^char * ptx_line_stats_filename = NULL;$/;"	v
ptx_opcocde_latency_options	cuda-sim.cc	/^void ptx_opcocde_latency_options (option_parser_t opp) {$/;"	f
ptx_parser_INCLUDED	ptx_parser.h	29;"	d
ptx_print_insn	cuda-sim.cc	/^void ptx_print_insn( address_type pc, FILE *fp )$/;"	f
ptx_reg_options	ptx_loader.cc	/^void ptx_reg_options(option_parser_t opp)$/;"	f
ptx_reg_t	ptx_sim.h	/^   ptx_reg_t() {$/;"	f	union:ptx_reg_t
ptx_reg_t	ptx_sim.h	/^   ptx_reg_t(unsigned x) $/;"	f	union:ptx_reg_t
ptx_reg_t	ptx_sim.h	/^union ptx_reg_t {$/;"	u
ptx_round	instructions.cc	/^void ptx_round(ptx_reg_t& data, int rounding_mode, int type)$/;"	f
ptx_saturate	instructions.cc	/^void ptx_saturate(ptx_reg_t& data, int saturation_mode, int type)$/;"	f
ptx_sim_h_INCLUDED	ptx_sim.h	28;"	d
ptx_sim_init_thread	cuda-sim.cc	/^unsigned ptx_sim_init_thread( kernel_info_t &kernel,$/;"	f
ptx_sim_kernel_info	cuda-sim.cc	/^const struct gpgpu_ptx_sim_kernel_info* ptx_sim_kernel_info(const function_info *kernel) $/;"	f
ptx_tex_regs	instructions.cc	/^ptx_reg_t* ptx_tex_regs = NULL;$/;"	v
ptx_thread_info	ptx_sim.cc	/^ptx_thread_info::ptx_thread_info( kernel_info_t &kernel )$/;"	f	class:ptx_thread_info
ptx_thread_info	ptx_sim.h	/^class ptx_thread_info {$/;"	c
ptx_version	ptx_sim.h	/^      ptx_version()$/;"	f	class:ptx_version
ptx_version	ptx_sim.h	/^      ptx_version(float ver, unsigned extensions)$/;"	f	class:ptx_version
ptx_version	ptx_sim.h	/^class ptx_version {$/;"	c
ptxinfo_cmem	cuda-sim.cc	/^void ptxinfo_cmem( unsigned nbytes, unsigned bank )$/;"	f
ptxinfo_function	cuda-sim.cc	/^void ptxinfo_function(const char *fname )$/;"	f
ptxinfo_lmem	cuda-sim.cc	/^void ptxinfo_lmem( unsigned declared, unsigned system )$/;"	f
ptxinfo_opencl_addinfo	cuda-sim.cc	/^void ptxinfo_opencl_addinfo( std::map<std::string,function_info*> &kernels )$/;"	f
ptxinfo_regs	cuda-sim.cc	/^void ptxinfo_regs( unsigned nregs )$/;"	f
ptxinfo_smem	cuda-sim.cc	/^void ptxinfo_smem( unsigned declared, unsigned system )$/;"	f
push_breakaddr	ptx_sim.cc	/^void ptx_thread_info::push_breakaddr(const operand_info &breakaddr) $/;"	f	class:ptx_thread_info
rcp_impl	instructions.cc	/^void rcp_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
read	memory.cc	/^template<unsigned BSIZE> void memory_space_impl<BSIZE>::read( mem_addr_t addr, size_t length, void *data ) const$/;"	f	class:memory_space_impl
read	memory.h	/^   void read( unsigned offset, size_t length, unsigned char *data ) const$/;"	f	class:mem_storage
read_parser_environment_variables	ptx_parser.cc	/^void read_parser_environment_variables() $/;"	f
read_sim_environment_variables	cuda-sim.cc	/^void read_sim_environment_variables() $/;"	f
read_single_block	memory.cc	/^template<unsigned BSIZE> void memory_space_impl<BSIZE>::read_single_block( mem_addr_t blk_idx, mem_addr_t addr, size_t length, void *data) const$/;"	f	class:memory_space_impl
rec_pts	cuda-sim.cc	/^struct rec_pts {$/;"	s	file:
red_impl	instructions.cc	/^void red_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
reduce_precision	instructions.cc	/^float reduce_precision( float x, unsigned bits )$/;"	f
reg1_num	ptx_ir.h	/^   int reg1_num() const { return m_value.m_vector_symbolic[0]->reg_num();}$/;"	f	class:operand_info
reg2_num	ptx_ir.h	/^   int reg2_num() const { return m_value.m_vector_symbolic[1]->reg_num();}$/;"	f	class:operand_info
reg3_num	ptx_ir.h	/^   int reg3_num() const { return m_value.m_vector_symbolic[2]?m_value.m_vector_symbolic[2]->reg_num():0; }$/;"	f	class:operand_info
reg4_num	ptx_ir.h	/^   int reg4_num() const { return m_value.m_vector_symbolic[3]?m_value.m_vector_symbolic[3]->reg_num():0; }$/;"	f	class:operand_info
reg_map_t	ptx_sim.h	/^   typedef tr1_hash_map<const symbol*,ptx_reg_t> reg_map_t;$/;"	t	class:ptx_thread_info
reg_num	ptx_ir.h	/^   int reg_num() const { return m_value.m_symbolic->reg_num();}$/;"	f	class:operand_info
reg_num	ptx_ir.h	/^   unsigned reg_num() const$/;"	f	class:symbol
reg_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
registerExit	ptx_sim.h	/^   void registerExit(){m_cta_info->register_thread_exit(this);}$/;"	f	class:ptx_thread_info
register_deleted_thread	ptx_sim.cc	/^void ptx_cta_info::register_deleted_thread( ptx_thread_info *thd )$/;"	f	class:ptx_cta_info
register_thread_exit	ptx_sim.cc	/^void ptx_cta_info::register_thread_exit( ptx_thread_info *thd )$/;"	f	class:ptx_cta_info
rem_impl	instructions.cc	/^void rem_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
remove_args	ptx_ir.h	/^   void remove_args()$/;"	f	class:function_info
reset_symtab	ptx_parser.cc	/^void *reset_symtab()$/;"	f
ret_impl	instructions.cc	/^void ret_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
retp_impl	instructions.cc	/^void retp_impl( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f
rounding_mode	ptx.y	/^rounding_mode: floating_point_rounding_mode$/;"	l
rounding_mode	ptx_ir.h	/^   unsigned rounding_mode() const { return m_rounding_mode;}$/;"	f	class:ptx_instruction
rpc_updated	ptx_sim.h	/^   bool rpc_updated() const { return m_RPC_updated; }$/;"	f	class:ptx_thread_info
rsqrt_impl	instructions.cc	/^void rsqrt_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
s16	ptx_sim.h	/^   signed short      s16;$/;"	m	union:ptx_reg_t
s2f	instructions.cc	/^ptx_reg_t s2f( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
s32	ptx_sim.h	/^   signed int        s32;$/;"	m	union:ptx_reg_t
s64	ptx_sim.h	/^   signed long long  s64;$/;"	m	union:ptx_reg_t
s8	ptx_sim.h	/^   signed char       s8;$/;"	m	union:ptx_reg_t
s_g_pc_to_insn	cuda-sim.cc	/^std::vector<ptx_instruction*> function_info::s_g_pc_to_insn;$/;"	m	class:function_info	file:
s_g_pc_to_insn	ptx_ir.h	/^   static std::vector<ptx_instruction*> s_g_pc_to_insn; \/\/ a direct mapping from PC to instruction$/;"	m	class:function_info
s_kernel_recon_points	cuda-sim.cc	/^   gpgpu_recon_t *s_kernel_recon_points;$/;"	m	struct:rec_pts	file:
s_num_recon	cuda-sim.cc	/^   int s_num_recon;$/;"	m	struct:rec_pts	file:
sad_impl	instructions.cc	/^void sad_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
saturated2i	instructions.cc	/^double saturated2i (double a, double max, double min) {$/;"	f
saturatei	instructions.cc	/^int saturatei(int a, int max, int min) $/;"	f
saturatei	instructions.cc	/^unsigned int saturatei(unsigned int a, unsigned int max) $/;"	f
saturation_mode	ptx_ir.h	/^   unsigned saturation_mode() const { return m_saturation_mode;}$/;"	f	class:ptx_instruction
scalar_type	ptx.y	/^scalar_type: S8_TYPE { add_scalar_type_spec( S8_TYPE ); }$/;"	l
scalar_type	ptx_ir.h	/^   int  scalar_type() const { return m_scalar_type_spec;}$/;"	f	class:type_info_key
selp_impl	instructions.cc	/^void selp_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
set_PC	ptx_ir.h	/^   void set_PC( addr_t PC )$/;"	f	class:ptx_instruction
set_addr_space	ptx_ir.h	/^   void set_addr_space(enum _memory_space_t set_value) { m_addr_space = set_value; }$/;"	f	class:operand_info
set_address	ptx_ir.h	/^   void set_address( addr_t addr )$/;"	f	class:symbol
set_array_dim	ptx_ir.h	/^   void set_array_dim( int array_dim ) { m_array_dim = array_dim; }$/;"	f	class:type_info_key
set_const_mem_offset	ptx_ir.h	/^   void set_const_mem_offset(addr_t set_value) { m_const_mem_offset = set_value; }$/;"	f	class:operand_info
set_ctaid	ptx_sim.h	/^   void set_ctaid( dim3 ctaid ) { m_ctaid = ctaid; }$/;"	f	class:ptx_thread_info
set_done	ptx_sim.cc	/^void ptx_thread_info::set_done() $/;"	f	class:ptx_thread_info
set_double_operand_type	ptx_ir.h	/^   void set_double_operand_type(int set_value) {  m_double_operand_type = set_value; }$/;"	f	class:operand_info
set_fp_or_int_archop	cuda-sim.cc	/^void ptx_instruction::set_fp_or_int_archop(){$/;"	f	class:ptx_instruction
set_framesize	ptx_ir.h	/^   void set_framesize( unsigned sz )$/;"	f	class:function_info
set_function	ptx_ir.h	/^   void set_function( function_info *func )$/;"	f	class:symbol
set_immediate_addr	ptx_ir.h	/^   void set_immediate_addr() {m_immediate_address=true;}$/;"	f	class:operand_info
set_immediate_operand_type	ptx_parser.cc	/^void set_immediate_operand_type ()$/;"	f
set_impl	instructions.cc	/^void set_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
set_info	ptx_sim.cc	/^void ptx_thread_info::set_info( function_info *func ) $/;"	f	class:ptx_thread_info
set_is_func	ptx_ir.h	/^   void set_is_func()$/;"	f	class:type_info_key
set_is_non_arch_reg	ptx_ir.h	/^   void set_is_non_arch_reg() { m_is_non_arch_reg = true;  }$/;"	f	class:type_info_key
set_kernel_info	ptx_ir.h	/^   const void set_kernel_info (const struct gpgpu_ptx_sim_kernel_info &info) {$/;"	f	class:function_info
set_label_address	ptx_ir.cc	/^void symbol_table::set_label_address( const symbol *label, unsigned addr )$/;"	f	class:symbol_table
set_label_address	ptx_ir.h	/^   void set_label_address( addr_t addr)$/;"	f	class:symbol
set_m_instr_mem_index	ptx_ir.h	/^   void set_m_instr_mem_index(unsigned index) {$/;"	f	class:ptx_instruction
set_mul_div_or_other_archop	cuda-sim.cc	/^void ptx_instruction::set_mul_div_or_other_archop(){$/;"	f	class:ptx_instruction
set_name	ptx_ir.cc	/^void symbol_table::set_name( const char *name )$/;"	f	class:symbol_table
set_name	ptx_ir.h	/^   void set_name(const char *name)$/;"	f	class:function_info
set_nctaid	ptx_sim.h	/^   void set_nctaid( dim3 cta_size ) { m_nctaid = cta_size; }$/;"	f	class:ptx_thread_info
set_neg_pred	ptx_ir.h	/^   void set_neg_pred()$/;"	f	class:operand_info
set_npc	ptx_sim.cc	/^void ptx_thread_info::set_npc( const function_info *f )$/;"	f	class:ptx_thread_info
set_npc	ptx_sim.h	/^   void set_npc( unsigned npc )$/;"	f	class:ptx_thread_info
set_ntid	ptx_sim.h	/^   void set_ntid( dim3 tid ) { m_ntid = tid; }$/;"	f	class:ptx_thread_info
set_opcode_and_latency	cuda-sim.cc	/^void ptx_instruction::set_opcode_and_latency()$/;"	f	class:ptx_instruction
set_operand_lohi	ptx_ir.h	/^   void set_operand_lohi(int set_value) { m_operand_lohi = set_value; }$/;"	f	class:operand_info
set_operand_neg	ptx_ir.h	/^   void set_operand_neg() { m_operand_neg = true; }$/;"	f	class:operand_info
set_operand_value	instructions.cc	/^void ptx_thread_info::set_operand_value( const operand_info &dst, const ptx_reg_t &data, unsigned type, ptx_thread_info *thread, const ptx_instruction *pI )$/;"	f	class:ptx_thread_info
set_operand_value	instructions.cc	/^void ptx_thread_info::set_operand_value( const operand_info &dst, const ptx_reg_t &data, unsigned type, ptx_thread_info *thread, const ptx_instruction *pI, int overflow, int carry )$/;"	f	class:ptx_thread_info
set_param_gpgpu_num_shaders	cuda-sim.cc	/^void set_param_gpgpu_num_shaders(int num_shaders)$/;"	f
set_ptx_version	ptx_ir.cc	/^void symbol_table::set_ptx_version( float ver, unsigned ext ) $/;"	f	class:symbol_table
set_ptx_warp_size	ptx_parser.cc	/^void set_ptx_warp_size(const struct core_config * warp_size)$/;"	f
set_reg	instructions.cc	/^void ptx_thread_info::set_reg( const symbol *reg, const ptx_reg_t &value ) $/;"	f	class:ptx_thread_info
set_regno	ptx_ir.h	/^   void set_regno( unsigned regno, unsigned arch_regno )$/;"	f	class:symbol
set_return	ptx_ir.h	/^   void set_return() { m_is_return_var = true; }$/;"	f	class:operand_info
set_return	ptx_parser.cc	/^void set_return()$/;"	f
set_single_thread_single_block	ptx_sim.h	/^   void set_single_thread_single_block()$/;"	f	class:ptx_thread_info
set_sm_target	ptx_ir.cc	/^void symbol_table::set_sm_target( const char *target, const char *ext, const char *ext2 )$/;"	f	class:symbol_table
set_symtab	ptx_ir.h	/^   void set_symtab(symbol_table *symtab )$/;"	f	class:function_info
set_symtab	ptx_parser.cc	/^void set_symtab(void*symtab)$/;"	f
set_target	ptx_sim.h	/^      void set_target( const char *sm_ver, const char *ext, const char *ext2 ) $/;"	f	class:ptx_version
set_tid	ptx_sim.h	/^   void set_tid( dim3 tid ) { m_tid = tid; }$/;"	f	class:ptx_thread_info
set_type	ptx_ir.h	/^   void set_type( enum operand_type type ) $/;"	f	class:operand_info
set_valid	ptx_sim.h	/^   void set_valid() { m_valid = true;}$/;"	f	class:ptx_thread_info
set_variable_type	ptx_parser.cc	/^void set_variable_type()$/;"	f
set_vector_operand_values	instructions.cc	/^void ptx_thread_info::set_vector_operand_values( const operand_info &dst, $/;"	f	class:ptx_thread_info
set_watch	memory.cc	/^template<unsigned BSIZE> void memory_space_impl<BSIZE>::set_watch( addr_t addr, unsigned watchpoint ) $/;"	f	class:memory_space_impl
setp_impl	instructions.cc	/^void setp_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
sexd	instructions.cc	/^ptx_reg_t sexd( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
sext	instructions.cc	/^ptx_reg_t sext( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
shared_to_generic	cuda-sim.cc	/^addr_t shared_to_generic( unsigned smid, addr_t addr )$/;"	f
shl_impl	instructions.cc	/^void shl_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
shr_impl	instructions.cc	/^void shr_impl( const ptx_instruction *pI, ptx_thread_info *thread )$/;"	f
sign_extend	instructions.cc	/^void sign_extend( ptx_reg_t &data, unsigned src_size, const operand_info &dst )$/;"	f
sin_impl	instructions.cc	/^void sin_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
size	ptx_sim.h	/^   size_t size;$/;"	m	struct:param_t
slct_impl	instructions.cc	/^void slct_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
sm_next_uid	ptx_ir.cc	/^unsigned function_info::sm_next_uid = 1;$/;"	m	class:function_info	file:
sm_next_uid	ptx_ir.cc	/^unsigned operand_info::sm_next_uid=1;$/;"	m	class:operand_info	file:
sm_next_uid	ptx_ir.cc	/^unsigned symbol::sm_next_uid = 1;$/;"	m	class:symbol	file:
sm_next_uid	ptx_ir.h	/^   static unsigned sm_next_uid;$/;"	m	class:function_info
sm_next_uid	ptx_ir.h	/^   static unsigned sm_next_uid;$/;"	m	class:operand_info
sm_next_uid	ptx_ir.h	/^   static unsigned sm_next_uid;$/;"	m	class:symbol
smem_n_way_bank_conflict_total	ptx-stats.cc	/^    unsigned long long smem_n_way_bank_conflict_total;  \/\/ total number of banks accessed by this instruction$/;"	m	class:ptx_file_line_stats	file:
smem_warp_count	ptx-stats.cc	/^    unsigned long smem_warp_count;                      \/\/ number of warps accessing shared memory$/;"	m	class:ptx_file_line_stats	file:
source_file	ptx_ir.h	/^   const char *source_file() const { return m_source_file.c_str();} $/;"	f	class:ptx_instruction
source_inst	ptx_ir.h	/^   class ptx_instruction* source_inst;$/;"	m	struct:gpgpu_recon_t	typeref:class:gpgpu_recon_t::ptx_instruction
source_line	ptx_ir.h	/^   unsigned source_line() const { return m_source_line;}$/;"	f	class:ptx_instruction
source_pc	ptx_ir.h	/^   address_type source_pc;$/;"	m	struct:gpgpu_recon_t
space_spec	ptx.y	/^space_spec: REG_DIRECTIVE {  add_space_spec(reg_space,0); }$/;"	l
special_regs	opcodes.h	/^enum special_regs {$/;"	g
sqrt_impl	instructions.cc	/^void sqrt_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
src1	ptx_ir.h	/^   const operand_info &src1() const $/;"	f	class:ptx_instruction
src2	ptx_ir.h	/^   const operand_info &src2() const $/;"	f	class:ptx_instruction
src3	ptx_ir.h	/^   const operand_info &src3() const $/;"	f	class:ptx_instruction
srcOperandModifiers	instructions.cc	/^ptx_reg_t srcOperandModifiers(ptx_reg_t opData, operand_info opInfo, operand_info dstInfo, unsigned type, ptx_thread_info *thread)$/;"	f
ssy_impl	instructions.cc	/^void ssy_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
st	ptx-stats.cc	/^    std::string st;$/;"	m	class:ptx_file_line	file:
st_impl	instructions.cc	/^void st_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
stack_entry	ptx_sim.h	/^   stack_entry( symbol_table *s, function_info *f, unsigned pc, unsigned rpc, const symbol *return_var_src, const symbol *return_var_dst, unsigned call_uid )$/;"	f	struct:stack_entry
stack_entry	ptx_sim.h	/^   stack_entry() {$/;"	f	struct:stack_entry
stack_entry	ptx_sim.h	/^struct stack_entry {$/;"	s
start_function	ptx_parser.cc	/^void start_function( int entry_point ) $/;"	f
statement_block	ptx.y	/^statement_block: LEFT_BRACE statement_list RIGHT_BRACE $/;"	l
statement_list	ptx.y	/^statement_list: directive_statement { add_directive(); }$/;"	l
sub_count	ptx-stats.cc	/^    void sub_count(const ptx_instruction * pInsn, int count = 1)$/;"	f	class:ptx_inflight_memory_insn_tracker
sub_impl	instructions.cc	/^void sub_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
subc_impl	instructions.cc	/^void subc_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
successor_ids	ptx_ir.h	/^   std::set<int> successor_ids;$/;"	m	struct:basic_block_t
suld_impl	instructions.cc	/^void suld_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
suq_impl	instructions.cc	/^void suq_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
sured_impl	instructions.cc	/^void sured_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
sust_impl	instructions.cc	/^void sust_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
symbol	ptx_ir.h	/^   symbol( const char *name, const type_info *type, const char *location, unsigned size ) $/;"	f	class:symbol
symbol	ptx_ir.h	/^class symbol {$/;"	c
symbol_table	ptx_ir.cc	/^symbol_table::symbol_table( const char *scope_name, unsigned entry_point, symbol_table *parent )$/;"	f	class:symbol_table
symbol_table	ptx_ir.cc	/^symbol_table::symbol_table() $/;"	f	class:symbol_table
symbol_table	ptx_ir.h	/^class symbol_table {$/;"	c
symbolic_t	ptx_ir.h	/^   unsigned_t, symbolic_t, label_t, v_reg_t, v_float_op_t, v_double_op_t,$/;"	e	enum:operand_type
target	ptx_sim.h	/^      unsigned target() const { assert(m_valid&&m_sm_version_valid); return m_sm_version; }$/;"	f	class:ptx_version
target_header	ptx_parser.cc	/^void target_header(char* a) $/;"	f
target_header2	ptx_parser.cc	/^void target_header2(char* a, char* b) $/;"	f
target_header3	ptx_parser.cc	/^void target_header3(char* a, char* b, char* c) $/;"	f
target_inst	ptx_ir.h	/^   class ptx_instruction* target_inst;$/;"	m	struct:gpgpu_recon_t	typeref:class:gpgpu_recon_t::ptx_instruction
target_pc	ptx_ir.h	/^   address_type target_pc;$/;"	m	struct:gpgpu_recon_t
texAddr_t	instructions.cc	/^typedef unsigned (*texAddr_t) (unsigned x, unsigned y, unsigned mx, unsigned my, size_t elem_size);$/;"	t	file:
tex_impl	instructions.cc	/^void tex_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
tex_linf_sampling	instructions.cc	/^float tex_linf_sampling(memory_space* mem, unsigned tex_array_base, $/;"	f
tex_operand	ptx.y	/^tex_operand: LEFT_SQUARE_BRACKET IDENTIFIER COMMA { add_scalar_operand($2); }$/;"	l
texel_size	ptx_ir.h	/^   unsigned int texel_size; \/\/size in bytes, e.g. (channelDesc.x+y+z+w)\/8$/;"	m	struct:textureInfo
texel_size_numbits	ptx_ir.h	/^   unsigned int texel_size_numbits; \/\/log2(texel_size)$/;"	m	struct:textureInfo
textureInfo	ptx_ir.h	/^struct textureInfo {$/;"	s
textureNormalizeElementSigned	instructions.cc	/^float textureNormalizeElementSigned(int element, int bits)$/;"	f
textureNormalizeElementUnsigned	instructions.cc	/^float textureNormalizeElementUnsigned(unsigned int element, int bits)$/;"	f
textureNormalizeOutput	instructions.cc	/^void textureNormalizeOutput( const struct cudaChannelFormatDesc& desc, ptx_reg_t& datax, ptx_reg_t& datay, ptx_reg_t& dataz, ptx_reg_t& dataw ) $/;"	f
to_string	ptx_ir.cc	/^std::string ptx_instruction::to_string() const$/;"	f	class:ptx_instruction
translate_pc_to_ptxlineno	cuda-sim.cc	/^unsigned translate_pc_to_ptxlineno(unsigned pc)$/;"	f
trap_impl	instructions.cc	/^void trap_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
tuple	ptxinfo.y	/^tuple: INT_OPERAND PLUS INT_OPERAND BYTES { g_declared=$1; g_system=$3; }$/;"	l
twin_operand	ptx.y	/^twin_operand : IDENTIFIER PLUS IDENTIFIER { add_double_operand($1,$3); change_double_operand_type(1); }$/;"	l
txq_impl	instructions.cc	/^void txq_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
type	ptx_ir.h	/^   const type_info *type() const { return m_type;}$/;"	f	class:symbol
type	ptx_sim.h	/^   int type;$/;"	m	struct:param_t
type_decode	ptx_ir.cc	/^unsigned type_info_key::type_decode( int type, size_t &size, int &basic_type )$/;"	f	class:type_info_key
type_decode	ptx_ir.cc	/^unsigned type_info_key::type_decode( size_t &size, int &basic_type ) const$/;"	f	class:type_info_key
type_info	ptx_ir.h	/^   type_info( symbol_table *scope, type_info_key t )$/;"	f	class:type_info
type_info	ptx_ir.h	/^class type_info {$/;"	c
type_info_key	ptx_ir.h	/^   type_info_key( memory_space_t space_spec, int scalar_type_spec, int vector_spec, int alignment_spec, int extern_spec, int array_dim )$/;"	f	class:type_info_key
type_info_key	ptx_ir.h	/^   type_info_key()$/;"	f	class:type_info_key
type_info_key	ptx_ir.h	/^class type_info_key {$/;"	c
type_info_key_compare	ptx_ir.h	/^struct type_info_key_compare {$/;"	s
type_spec	ptx.y	/^type_spec: scalar_type $/;"	l
u128	ptx_sim.h	/^   } u128;$/;"	m	union:ptx_reg_t	typeref:struct:ptx_reg_t::__anon2
u16	ptx_sim.h	/^   unsigned short    u16;$/;"	m	union:ptx_reg_t
u2f	instructions.cc	/^ptx_reg_t u2f( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
u32	ptx_sim.h	/^   unsigned int      u32;$/;"	m	union:ptx_reg_t
u64	ptx_sim.h	/^   unsigned long long   u64;$/;"	m	union:ptx_reg_t
u8	ptx_sim.h	/^   unsigned char     u8;$/;"	m	union:ptx_reg_t
uid	ptx_ir.h	/^   unsigned uid() const { return m_uid; }$/;"	f	class:symbol
uid	ptx_ir.h	/^   unsigned uid() const { return m_uid;}$/;"	f	class:ptx_instruction
uint4	cuda-math.h	/^   struct uint4 {$/;"	s	namespace:cuda_math
uint4	cuda-math.h	/^   typedef struct uint4 uint4;$/;"	t	namespace:cuda_math	typeref:struct:cuda_math::uint4
undef_t	ptx_ir.h	/^   v_int_t, v_unsigned_t, undef_t$/;"	e	enum:operand_type
unsigned_t	ptx_ir.h	/^   unsigned_t, symbolic_t, label_t, v_reg_t, v_float_op_t, v_double_op_t,$/;"	e	enum:operand_type
update_pc	ptx_sim.h	/^   void update_pc( )$/;"	f	class:ptx_thread_info
v_double_op_t	ptx_ir.h	/^   unsigned_t, symbolic_t, label_t, v_reg_t, v_float_op_t, v_double_op_t,$/;"	e	enum:operand_type
v_float_op_t	ptx_ir.h	/^   unsigned_t, symbolic_t, label_t, v_reg_t, v_float_op_t, v_double_op_t,$/;"	e	enum:operand_type
v_int_t	ptx_ir.h	/^   v_int_t, v_unsigned_t, undef_t$/;"	e	enum:operand_type
v_reg_t	ptx_ir.h	/^   unsigned_t, symbolic_t, label_t, v_reg_t, v_float_op_t, v_double_op_t,$/;"	e	enum:operand_type
v_unsigned_t	ptx_ir.h	/^   v_int_t, v_unsigned_t, undef_t$/;"	e	enum:operand_type
vabsdiff_impl	instructions.cc	/^void vabsdiff_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
vadd_impl	instructions.cc	/^void vadd_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
var_spec	ptx.y	/^var_spec: space_spec $/;"	l
var_spec_list	ptx.y	/^var_spec_list: var_spec $/;"	l
variable_declaration	ptx.y	/^variable_declaration: variable_spec identifier_list { add_variables(); }$/;"	l
variable_spec	ptx.y	/^variable_spec: var_spec_list { set_variable_type(); }$/;"	l
vec_name1	ptx_ir.h	/^   const std::string &vec_name1() const$/;"	f	class:operand_info
vec_name2	ptx_ir.h	/^   const std::string &vec_name2() const$/;"	f	class:operand_info
vec_name3	ptx_ir.h	/^   const std::string &vec_name3() const$/;"	f	class:operand_info
vec_name4	ptx_ir.h	/^   const std::string &vec_name4() const$/;"	f	class:operand_info
vec_symbol	ptx_ir.h	/^   const symbol* vec_symbol(int idx) const $/;"	f	class:operand_info
vector_operand	ptx.y	/^vector_operand: LEFT_BRACE IDENTIFIER COMMA IDENTIFIER RIGHT_BRACE { add_2vector_operand($2,$4); }$/;"	l
vector_spec	ptx.y	/^vector_spec:  V2_TYPE {  add_option(V2_TYPE); func_header_info(".v2");}$/;"	l
vector_t	ptx_ir.h	/^   reg_t, vector_t, builtin_t, address_t, memory_t, float_op_t, double_op_t, int_t, $/;"	e	enum:operand_type
ver	ptx_sim.h	/^      float    ver() const { assert(m_valid); return m_ptx_version; }$/;"	f	class:ptx_version
version_header	ptx_parser.cc	/^void version_header(double a) {}  \/\/intentional dummy function$/;"	f
vmad_impl	instructions.cc	/^void vmad_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
vmax_impl	instructions.cc	/^void vmax_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
vmin_impl	instructions.cc	/^void vmin_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
vote_all	ptx_ir.h	/^   enum vote_mode_t { vote_any, vote_all, vote_uni, vote_ballot };$/;"	e	enum:ptx_instruction::vote_mode_t
vote_any	ptx_ir.h	/^   enum vote_mode_t { vote_any, vote_all, vote_uni, vote_ballot };$/;"	e	enum:ptx_instruction::vote_mode_t
vote_ballot	ptx_ir.h	/^   enum vote_mode_t { vote_any, vote_all, vote_uni, vote_ballot };$/;"	e	enum:ptx_instruction::vote_mode_t
vote_impl	instructions.cc	/^void vote_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
vote_mode	ptx_ir.h	/^   enum vote_mode_t vote_mode() const { return m_vote_mode; }$/;"	f	class:ptx_instruction
vote_mode_t	ptx_ir.h	/^   enum vote_mode_t { vote_any, vote_all, vote_uni, vote_ballot };$/;"	g	class:ptx_instruction
vote_uni	ptx_ir.h	/^   enum vote_mode_t { vote_any, vote_all, vote_uni, vote_ballot };$/;"	e	enum:ptx_instruction::vote_mode_t
vset_impl	instructions.cc	/^void vset_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
vshl_impl	instructions.cc	/^void vshl_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
vshr_impl	instructions.cc	/^void vshr_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
vsub_impl	instructions.cc	/^void vsub_impl( const ptx_instruction *pI, ptx_thread_info *thread ) { inst_not_implemented(pI); }$/;"	f
w	cuda-math.h	/^      float x, y, z, w;$/;"	m	struct:cuda_math::float4
w	cuda-math.h	/^      int x, y, z, w;$/;"	m	struct:cuda_math::int4
w	cuda-math.h	/^      unsigned int x, y, z, w;$/;"	m	struct:cuda_math::uint4
warp_divergence	ptx-stats.cc	/^    unsigned long long warp_divergence; \/\/ number of warp divergence occured at this instruction$/;"	m	class:ptx_file_line_stats	file:
warp_exit	cuda-sim.cc	/^void functionalCoreSim::warp_exit( unsigned warp_id )$/;"	f	class:functionalCoreSim
warp_waiting_at_barrier	cuda-sim.h	/^    virtual bool warp_waiting_at_barrier( unsigned warp_id ) const  $/;"	f	class:functionalCoreSim
whichspace	cuda-sim.cc	/^memory_space_t whichspace( addr_t addr )$/;"	f
wrap	instructions.cc	/^unsigned wrap( unsigned x, unsigned y, unsigned mx, unsigned my, size_t elem_size )$/;"	f
write	memory.cc	/^template<unsigned BSIZE> void memory_space_impl<BSIZE>::write( mem_addr_t addr, size_t length, const void *data, class ptx_thread_info *thd, const ptx_instruction *pI)$/;"	f	class:memory_space_impl
write	memory.h	/^   void write( unsigned offset, size_t length, const unsigned char *data )$/;"	f	class:mem_storage
x	cuda-math.h	/^      float x, y, z, w;$/;"	m	struct:cuda_math::float4
x	cuda-math.h	/^      float x, y;$/;"	m	struct:cuda_math::float2
x	cuda-math.h	/^      int x, y, z, w;$/;"	m	struct:cuda_math::int4
x	cuda-math.h	/^      unsigned int x, y, z, w;$/;"	m	struct:cuda_math::uint4
xor_impl	instructions.cc	/^void xor_impl( const ptx_instruction *pI, ptx_thread_info *thread ) $/;"	f
y	cuda-math.h	/^      float x, y, z, w;$/;"	m	struct:cuda_math::float4
y	cuda-math.h	/^      float x, y;$/;"	m	struct:cuda_math::float2
y	cuda-math.h	/^      int x, y, z, w;$/;"	m	struct:cuda_math::int4
y	cuda-math.h	/^      unsigned int x, y, z, w;$/;"	m	struct:cuda_math::uint4
z	cuda-math.h	/^      float x, y, z, w;$/;"	m	struct:cuda_math::float4
z	cuda-math.h	/^      int x, y, z, w;$/;"	m	struct:cuda_math::int4
z	cuda-math.h	/^      unsigned int x, y, z, w;$/;"	m	struct:cuda_math::uint4
zext	instructions.cc	/^ptx_reg_t zext( ptx_reg_t x, unsigned from_width, unsigned to_width, int to_sign, int rounding_mode, int saturation_mode )$/;"	f
~arg_buffer_t	ptx_ir.h	/^   ~arg_buffer_t()$/;"	f	class:arg_buffer_t
~functionalCoreSim	cuda-sim.h	/^    virtual ~functionalCoreSim(){$/;"	f	class:functionalCoreSim
~mem_storage	memory.h	/^   ~mem_storage()$/;"	f	class:mem_storage
~memory_space	memory.h	/^   virtual ~memory_space() {}$/;"	f	class:memory_space
~ptx_thread_info	ptx_sim.cc	/^ptx_thread_info::~ptx_thread_info()$/;"	f	class:ptx_thread_info
